

# 标记清除算法

概念

    Mark-Sweep（标记-清除）

原理

    标记出所有需要被回收的对象，
    回收被标记的对象所占用的空间

图解

![](https://github.com/RodJohn/JVM/blob/master/img/gcmarksweep.jpg)
    
特点

    实现简单
    并发性能好不需要复制或者移动内存，SPW（Stop the world）
    
    容易产生内存碎片，
    碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。    
    
    
    
# 复制算法

概念
 
    Copying（复制）算法

原理

    将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。
    当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，


图解

![](https://github.com/RodJohn/JVM/blob/master/img/gccopy.jpg)

特点

    解决内存碎片问题
    但是能够使用的内存缩减到原来的一半。
    
    Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。
    当大量对象存活时，需要大量的内存复制
    
    
# 标记整理算法

概念

    Mark-Compact（标记-整理）算法
    
原理

    完成标记之后，
    将存活对象都向一端移动，然后清理掉端边界以外的内存
    
图解

![](https://github.com/RodJohn/JVM/blob/master/img/gcmarkcompact.jpg)

特点
  
    解决了内存碎片问题，比复制算法空间利用率高。
    因为有局部对象移动，相对效率不高。


# 分代收集算法

概述

    Generational Collection（分代收集）算法
    
原理

    根据对象存活的生命周期划分为堆中的新生代、老年代和方法区的永久代
    根据不同区域不同的特点，用不同回收算法去回收垃圾。
    
    对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象
        新生代由Eden区，From Survivor区，To Survivor区组成，比例一般8:1:1  
        GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的（作为保留区域）。
        GC进行时，Eden区中所有存活的对象都会被复制到To Survivor区，
        而在From Survivor区中，
        仍存活的对象会根据它们的年龄值和总量决定去向，被移到老年代中或者To Survivor区。
        接着清空Eden区和From Survivor区，
        接着， From Survivor区和To Survivor区会交换它们的角色，
        （也就是新的To Survivor区就是上次GC清空的From Survivor）
        GC时当To Survivor区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。


新生代垃圾回收的执行过程：
1、Eden 区 + From Survivor 区存活着的对象复制到 To Survivor 区；
2、清空 Eden 和 From Survivor 分区；
3、From Survivor 和 To Survivor 分区交换（From 变 To，To 变 From）。
老生代（Tenured Generation）
老生代垃圾回收的频率比新生代低，存放的主要对象是：
1、新生代对象经过 N 次 GC 晋升到老年代。
可以通过设置 -XX:MaxTenuringThreshold=5 来设置，默认值是 15 次。
2、大对象直接存储到老生代。
所谓的“大对象”指的是需要连续存储空间的对象，比如：数组。
当大对象在新生代存储不下的时候，就需要分配担保机制，把当前新生代的所有对象复制到老年代中，因为分配担保机制需要涉及大量的复制，会导致性能问题，所有最好的方案是直接把大对象存储到老生代中。


    对于老年代采用是Mark-Compact算法。因为每次回收都只回收少量对象

    对永久代的回收主要回收两部分内容：废弃常量和无用的类。        

特点

    通过分代，避免提高GC效率


survivor区的作用
    
    Survivor只是增加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性。
    
    minorGC快

分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是


分代比例

![](https://github.com/RodJohn/JVM/blob/master/img/gc%E5%88%86%E4%BB%A3%E7%A9%BA%E9%97%B4.png)


