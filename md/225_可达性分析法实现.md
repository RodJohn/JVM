

# 枚举根节点

    可达性分析法第一步是枚举根节点，  
    为了保证枚举期间对象引用不再变化，必须先暂停程序的执行（STW），  
    根节点一般是全局引用和栈上本地变量，  
    如果对全部内存扫描一遍，则将长时间暂停线程  

# OopMap

    HotSpot在类加载和JIT编译  
    使用OopMap来记录对象中引用的位置    
    这样就可以快速的完成GC Roots枚举

示例


# 安全点

安全点意义

    导致引用变化的指令很多，而且如果给每个对象生成对应的OopMap，会造成大量额外的空间  
    所以HotSpot只会在“特定的位置”生成对应的OopMap，这些位置就成为“安全点”

安全点设置

    HotSpot也并不是任何时刻都会停顿下来进行GC，只会在程序都到底安全点之后才会GC，  
    所以安全点的设置要保证程序执行时不需要太长时间就可以进入一个安全点进行 GC 动作

# 线程的GC中断方式

抢断式中断  

    不需要线程的执行代码去主动配合，当发生GC时，先强制中断所有线程，    
    然后如果发现某些线程未处于安全点，恢复程序运行，直到进入安全点为止。

主动式中断

    设置一个中断标记，各个线程在执行时轮询这个标记，  
    一旦发现标记被改变(出现中断标记)时，那么将运行到安全点后自己中断挂起。  
    目前所有商用虚拟机全部采用主动式中断。

# 安全区域

特殊情况

    当特殊情况时，比如线程休眠、线程阻塞等状态的情况下，
    显然HotSpot不可能一直等待被阻塞或休眠的线程正常唤醒执行；

安全区

    安全区域是指在一段区域内，对象引用关系等不会发生变化，在此区域内任意位置开始GC都是安全的；  


    线程运行时，首先标记自己进入了安全区，  
    然后在这段区域内，如果线程发生了阻塞、休眠等操作，HotSpot发起GC时将忽略这些处于安全区的线程。  
    当线程再次被唤醒时，首先他会检查是否完成了GC Roots枚举(或这个GC过程)，  
    如果完成了就继续执行，否则将继续等待直到收到可以安全离开的Safe Region的信号为止。


    ？？线程发生了阻塞、休眠一定在安全点、区


# 参考

https://dsxwjhf.iteye.com/blog/2201685  
