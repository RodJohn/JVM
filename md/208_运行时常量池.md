# 常量池

静态常量池

    即*.class文件中的常量池，
    用于存放字面量和符号引用

运行时常量池

    是jvm运行期间，
    存储常量的数据结构

# 运行时常量池

概念

    运行时常量池（Runtime Constant Pool）
    是方法区的一部分
    
    
作用
    
    用于存放各种常量
    避免频繁的创建和销毁对象而影响系统性能
    节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。

位置

     jdk1,6常量池放在方法区，
     jdk1.7常量池放在堆内存，
     jdk1.8放在元空间里面，和堆独立。
     
常量

    除了两种浮点数类型，其他基本类型的包装类都实现了常量池技术，
    这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，
    但是超出此范围仍然会去创建新的对象。
    
    Java语言并不要求常量一定只能在编译期产生，运行期间也可能产生新的常量。
    （可以通过String.intern()方法可以强制将String放入常量池）



# String和常量池

    每当我们创建字符串常量时，JVM会首先检查字符串常量池，
    如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。
    如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。
 
## 定义

字面量定义

    String a = "chenssy";

    编译期间，
    在常量池中查找或者创建chenssy"对象
    将栈中的a指向常量池中的"chenssy"对象

new关键字定义

    String c = new String("chenssy");

    运行期间
    在常量池中查找或者创建chenssy常量
    new关键字在堆中创建一个对象chenssy
    用chenssy常量的引用构建堆chenssy对象
    堆chenssy对象赋值给栈中的c
    应用关系是：c--->chenssy--->chenssy常量。
 
图例



示例

    @Test
    public void test2(){
        String str1="aaa";
        String str2="aaa";
        System.out.println(str1==str2);
        //true 
        //可以看出str1跟str2是指向同一个对象

        String str3=new String("aaa");
        String str4=new String("aaa");
        System.out.println(str3==str4);
        //false 
        //可以看出用new的方式是生成不同的对象 
    }


## 运算符+
常量

常量（字面量、final）相加
能明确值的常量
在编译期运算结果就确定为一个字面量字符串


变量

字符串变量相加，
内部实现是先new一个StringBuilder，
然后通过append()实现相加


示例

@Test
public void test3(){
    String str1="hello";
    String str2="world";
    String str3="helloworld";
    String str4="hello"+"world";
    String str5=str1+str2;
    String str6=new String("hello");
    String str7=new String("world");
    String str8=str6+str7;
    System.out.println(str3==str4);
    //true
    System.out.println(str3==str5);
    //false  *
    System.out.println(str3==str8);
    //false
    System.out.println(str3==str9);
    //false
}


String str4="hello"+"world";
在class文件中被优化成String str4="helloworld";


@Test
public void test4() {
    String s0 = "ab";
    final String s1 = "b";
    String s2 = "b";
    String s3 = getS1();
    String s10 = "a" + s1;
    String s11 = "a" + s2;
    String s12 = "a" + s3;
    System.out.println((s0 == s10));
    //true
    System.out.println((s0 == s11));
    //false
    System.out.println((s0 == s12));
    //false
}

private static String getS1() {
    return "b";
}


intern
作用

调用intern()方法时，java查找常量池中是否有相同unicode的字符串常量，
如果有，则返回其引用，
如果没有，则在常量池中增加一个unicode等于str的字符串并返回它的引用。
1
2
3
示例

String str1 = "abbb"; 
String str2 = new String("abbb").intern(); 
System.out.println(str1==str2); //true
1
2
3
Integer与常量池
示例
@Test
public void test1(){
    Integer i1 = 40;
    Integer i2 = 40;
    Integer i3 = 0;
    Integer i4 = new Integer(40);
    Integer i5 = new Integer(40);
    Integer i6 = new Integer(0);

    System.out.println("i1=i2   " + (i1 == i2));
    //true 
    System.out.println("i1=i2+i3   " + (i1 == i2 + i3));
    //true 
    System.out.println("i1=i4   " + (i1 == i4));
    //false
    System.out.println("i4=i5   " + (i4 == i5));
    //false        
    System.out.println("i4=i5+i6   " + (i4 == i5 + i6));
    //true 
    System.out.println("40=i5+i6   " + (40 == i5 + i6));
    //true 
}


解析
赋值

Integer i1=40；
Java在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);从而使用常量池中的对象。
Integer i1 = new Integer(40);这种情况下会创建新的对象。
1
2
3
运算

语句i4 == i5 + i6，
因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。
然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。
1
2
3
参考
https://www.cnblogs.com/xiaoxi/p/6036701.html            
https://blog.csdn.net/ychenfeng/article/details/77413206 

