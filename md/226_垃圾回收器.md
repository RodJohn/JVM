# 垃圾收集器


    现代的商用虚拟机的都是采用分代收集的，不同的区域用不同的收集器
    
    Serial、ParNew、Parallel Scavenge用于新生代；
    CMS、Serial Old、Paralled Old用于老年代。
    并且他们相互之间以相对固定的组合使用（具体组合关系如上图）。G1是一个独立的收集器不依赖其他6种收集器。ZGC是目前JDK 11的实验收集器。


![](https://github.com/RodJohn/JVM/blob/master/img/gccollectors.png)
   
    垃圾收集中的并行与并发：
    
    并行（Parallel）：多条垃圾收集线程
    并发（Concurrent）：用户线程与垃圾收集线程同时执行


分代的比例



# Serial

![](https://github.com/RodJohn/JVM/blob/master/img/gcserial.png)
    
特点

    新生代收集器
    使用复制算法
    使用单线程进行回收
    回收时暂停其他所有线程
    
适用情况    
    
    client模式下（内存小，回收快）
    单核CPU情况下（无需线程切换）
    
    
# ParNew
![](https://github.com/RodJohn/JVM/blob/master/img/gcparnew.png)

作用

    新生代收集器
    
特点

    Serial的多线程版本    
        使用多线程进行回收
        回收时暂停其他所有线程    
        
适用情况    
    
    多核CPU情况下
       
    ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，
    甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证能超越Serial收集器。
    当然，随着可以使用的CPU的数量增加，它对于GC时系统资源的利用还是很有好处的。
    它默认开启的收集线程数与CPU的数量相同，
    可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。
    
    除Serial外，只有它能与CMS收集器配合工作
    
    
# Parallel Scavenge

作用 
    
    新生代收集器
    
特点

    使用复制算法   
    使用多线程
    关注吞吐量
        （吞吐量=运行用户代码时间/CPU总时间)


参数        
    
    -XX:MaxGCPauseMillis，最大垃圾回收停顿时间。这个参数的原理是空间换时间，收集器会控制新生代的区域大小，从而尽可能保证回收少于这个最大停顿时间。简单的说就是回收的区域越小，那么耗费的时间也越小。
    所以这个参数并不是设置得越小越好。设太小的话，新生代空间会太小，从而更频繁的触发GC。
    -XX:GCTimeRatio，垃圾回收时间与总时间占比。这个是吞吐量的倒数，原理和MaxGCPauseMillis相同。
    
    因为Parallel Scavenge收集器关注的是吞吐量，所以当设置好以上参数的时候，同时不想设置各个区域大小（新生代，老年代等）。可以开启**-XX:UseAdaptiveSizePolicy**参数，让JVM监控收集的性能，动态调整这些区域大小参数。
    
        
适用情况
    
    停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能够提升用户的体验；
    而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
 
 
 
 # Serial Old 
 
作用
 
    老年代收集器
    
特点

    使用标记整理算法
    使用单线程 
    收集时暂停所有用户进程
    
    
适用情况

    Client模式下的虚拟机使用。
    在Server模式下，作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。
    
    
# Parallel Old


作用

    老年代收集器
    
特点

    
    采用多线程
    采用”标记－整理”算法
    关注吞吐量
    
适用情况
    
    Parallel Old收集器是Parallel Scavenge收集器的老年代版本，
    在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。   
    
    
# CMS

![](https://github.com/RodJohn/JVM/blob/master/img/gccms.png)

作用

    老年代收集器
    
特点

    使用标记清除算法
    关注最短回收停顿时间   
    由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。
    工作流程
        初始标记(initial mark)：找GC Roots
        并发标记(concurrent mark)：找引用链
        重新标记(remark)：查找变更
        并发清除(concurrent sweep)：清除
        注意初始标记和重新标记还是会stop the world，
        但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。                      

[]()         
 
缺点

    基于标记清除算法实现的，会导致有大量的空间碎片产生，
        在为大对象分配内存的时候，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前开启一次Full GC。
        为了解决这个问题，CMS收集器默认提供了一个-XX:+UseCMSCompactAtFullCollection收集开关参数（默认就是开启的)，
        用于在CMS收集器进行FullGC完开启内存碎片的合并整理过程，内存整理的过程是无法并发的，这样内存碎片问题倒是没有了，不过停顿时间不得不变长。
        虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction参数用于设置执行多少次不压缩的FULL GC后跟着来一次带压缩的
        （默认值为0，表示每次进入Full GC时都进行碎片整理）。     
        
    对cpu资源敏感
        垃圾收集线程数和每个收集线程占用cpu的时间受cpu数量影响
    
    无法处理“浮动垃圾”
        即并发清除阶段用户线程又产生的对象。
        -XX:CMSInitiatingOccupancyFranction：老年代被使用的百分比，达到时触发GC（如果等老年代占满了再GC，则GC时并发产生的对象可能就获取不到存储空间）
        CMSInitiatingOccupancyFranction过高会导致大量Concurrent Mode Failure，即老年代预留的内存无法满足程序需要。
        

    有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢？
    答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“Stop the World”这种场景下使用。
    
    
    a>.CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。
    CMS默认启动的回收线程数是：(CPU数量+3) / 4。b>.CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure“，失败后而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。
    这一部分垃圾称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分内存空间提供并发收集时的程序运作使用。
    在默认设置下，CMS收集器在老年代使用了68%的空间时就会被激活，也可以通过参数-XX:CMSInitiatingOccupancyFraction的值来提供触发百分比，以降低内存回收次数提高性能。要是CMS运行期间预留的内存无法满足程序其他线程需要，就会出现“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置的过高将会很容易导致“Concurrent Mode Failure”失败，性能反而降低。c>.最后一个缺点，CMS是基于“标记-清除”算法实现的收集器，使用“标记-清除”算法收集后，会产生大量碎片。空间碎片太多时，将会给对象分配带来很多麻烦，比如说大对象，内存空间找不到连续的空间来分配不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:UseCMSCompactAtFullCollection开关参数，用于在Full GC之后增加一个碎片整理过程，还可通过-XX:CMSFullGCBeforeCompaction参数设置执行多少次不压缩的Full GC之后，跟着来一次碎片整理过程。
