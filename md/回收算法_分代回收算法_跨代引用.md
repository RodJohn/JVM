
# 跨代引用
    
    分析跨带引用（例如老年代到年轻代的引用）有如下方法
    1.从 root 对象开始找到从老年代到年轻代的引用关系 - 比较耗时, 相当于整个 heap 都做引用关系图;
    2.忽略 root 对象, 扫描所有老年代对象, 然后找到从老年代到年轻代的引用 - 也挺多的.

    一般来说， 
    gc首先枚举根节点。  
    根节点有可能在新生代中，也有可能在老年代中。  
    如果是YGC的话，没必要对位于老年代的GCRoots进行可达性分析。  
    但确实可能存在位于老年代的某个 GC Root，它引用了新生代的某个对象  
    而新生代的RememberedSet就能描述这种情况  
    所以，“新生代的 GC Roots ” + “ 新生代RSet”，就能枚举出新生代真正的 GC Roots 。  

    而mixed gc的时候，  
    old generation中记录了old->old的RSet，young->old的引用由扫描全部young generation region得到  
    ，这样也不用扫描全部old generation region。  
    所以RSet的引入大大减少了GC的工作量。  

# 记录集

    记录集记录了老年代对象到新生代对象的引用
    新生代 GC 时，从记录集和根直接引用的新生代对象开始搜索
    就避免了对老年代的扫描
    
![](https://github.com/RodJohn/jvm/blob/master/img/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E9%9B%861.png)    
    
    
    记录集里记录是老年代对象
    point out记录发出引用的对象
    
    
![](https://github.com/RodJohn/jvm/blob/master/img/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E9%9B%862.png)    
   

# CardTable
    
    CardTable是记录集的一种应用

原理

    对老年代 heap 设立一个 dirty card 表. 
    例如对老年代每256K 映射到 dirty card 中的一个 bit,
    如果老年代有对年轻代的引用的时候(老年代对象字段值的修改), 把这个 bit 修改代表 dirty.

    
# 写入屏障

将老年代对象记录到记录集里，我们利用写入屏障(write barrier)


# 应用

新生代对象标记

    如果从根直接进行可达性分析,则每次都得扫描老年代对象
    (可达性分析法的效率和存活率成正比，老年代存活率很高，所以要浪费很多时间)
    适合使用记录集
    
老年代对象标记

    新生代到老年代的引用不适合使用记录集
    
    可以直接扫描新生代


# 参考

https://www.jianshu.com/p/5037459097ee  

