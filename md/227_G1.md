    
# G1 

概念

    G1，Garbage First，
    在JDK 1.7版本正式启用，是当时最前沿的垃圾收集器。
    G1可以说是CMS的终极改进版，解决了CMS内存碎片、更多的内存空间登问题。
    虽然流程与CMS比较相似，但底层的原理已是完全不同

作用

    独自完成新生代和老年代的搜集    
    
    最前沿成果。削弱新生代与老年代概念，将整个堆划分为独立的不同Region。根据各Region的回收价值，确定优先列表。
    
    从整体来看：“标记-整理” 算法
    
    从局部（两个Region之间）来看：“复制”算法 
    
    
    堆内存结构的不同。
    
        以前的收集器分代是划分新生代、老年代、持久代等。
        G1则是把内存分为多个大小相同的区域Region，每个Region拥有各自的分代属性，但这些分代不需要连续。
        
        这样的分区可以有效避免内存碎片化问题。
        
    但是这样同样会引申一个新的问题，就是分代的内存不连续，导致在GC搜索垃圾对象的时候需要全盘扫描找出引用内存所在。
    为了解决这个问题，G1对于每个Region都维护一个Remembered Set，用于记录对象引用的情况。当GC发生的时候根据Remembered Set的引用情况去搜索。


GC模式：

    Young GC，关注于所有年轻代的Region，通过控制收集年轻代的Region个数，从而控制GC的回收时间。
    Mixed GC，关注于所有年轻代的Region，并且加上通过预测计算最大收益的若干个老年代Region。
    
        
流程

    整体的执行流程：
    
    初始标记（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。
    并发标记（concurrent marking），并发标记初始标记的对象，此时用户线程依然可以执行。
    最终标记（Remark），STW，标记再并发标记过程中产生的垃圾。
    筛选回收（Live Data Counting And Evacuation），评估标记垃圾，根据GC模式回收垃圾。STW执行。
    
    
 

# 设置简单

    首先，G1的设计原则就是简单可行的性能调优
    开发人员仅仅需要声明以下参数即可：
    -XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200
    
    其中-XX:+UseG1GC为开启G1垃圾收集器，-Xmx32g 设计堆内存的最大内存为32G，-XX:MaxGCPauseMillis=200设置GC的最大暂停时间为200ms。如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可。


# G1将新生代，老年代的物理空间划分取消了

    不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够
    
    G1算法将堆划分为若干个区域（Region），
    它仍然属于分代收集器。
    不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。
    老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了
    
    在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。
    
    
    
# G1 Young GC

    Young GC主要是对Eden区进行GC，
    它在Eden空间耗尽时会被触发。
    Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。
    Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。
    最终Eden空间的数据为空，GC停止工作，应用线程继续执行。

Remembered Set

    作用是跟踪指向某个heap区内的对象引用

    在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，
    在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。
    
point-in
        
    但在G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的分区引用也扫描了。于是G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。
    需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1 中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址。默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。

   
参考

    http://blog.jobbole.com/109170/    
