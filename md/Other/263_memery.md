

32位虚拟机 VS 64位虚拟机：

由于指针膨胀和各种数据类型对齐补白的原因，运行于64位系统上的Java应用需要消耗更多的内存（通常比32位的增加10%~30%的内存开销） ；此外，64位虚拟机的运行速度比32位的大约有15%左右的性能差距。


# 理论

运算能力

所谓32位处理器就是一次只能处理32位，也就是4个字节的数据，
而64位处理器一次就能处理64位，即8个字节的数据。
如果我们将总长128位的指令分别按照16位、32位、64位为单位进行编辑的话：旧的16位处理器，比如Intel 80286 CPU需要8个指令，32位的处理器需要4个指令，而64位处理器则只要两个指令，显然，在工作频率相同的情况下，64位处理器的处理速度会比16位、32位的更快。

内存

而且除了运算能力之外，与32位处理器相比，64位处理器的优势还体现在系统对内存的控制上。由于地址使用的是特殊的整数，而64位处理器的一个ALU（算术逻辑运算器）和寄存器可以处理更大的整数，也就是更大的地址。传统32位处理器的寻址空间最大为4GB，使得很多需要大容量内存的数据处理程序在这时都会显得捉襟见肘，形成了运行效率的瓶颈。而64位的处理器在理论上则可以达到1800万个TB，所以64位的处理器能够彻底解决32位计算系统所遇到的瓶颈现象，速度快人一等，对于那些要求多处理器可扩展性、更大的可寻址内存、视频/音频/三维处理或较高计算准确性的应用程序而言，AMD 64处理器可提供卓越的性能。

# JVM

## 内存总量

理论上来说32位的JVM有4G的堆大小限制。但是因为各种条件限制比如交换区，内核地址空间使用，内存碎片，虚拟管理机的管理开销，实际上可用的堆的大小远远比理论上的4G要少。 
在32位windows的机器上，堆最大可以达到1.4G至1.6G。 
在32位solaris的机器上，堆最大可以达到2G 
而在64位的操作系统上，32位的JVM，堆大小可以达到4G 

补充一句，在使用java参数-xms -xmx定义堆大小的时候， 
1. 如果是32bit的jvm超过4G肯定是没用的，定义了4G，最终使用到的可能只有2G 
2. 这两个值最好定义成一样，可以减少java gc的操作，有小幅度性能提高 

## 变量

hotspot对象内存结构
头信息
对象对齐

## slot


## 指针

	对于 64位的JVM来说，系统中的本地指针会占用8个字节，而不是4个。这会导致你的程序的内存占用量的增加

指针压缩技术

## GC





Java虚拟机（JVM）是一个软件规范，其32位与64位版本性能有所不同，但它们都包括JIT编译器和垃圾回收功能（GC）,其性能关键在JIT编译器和垃圾回收功能的执行效率上。       JIT编译器实现了程序执行之前Java字节码到硬件机器码的动态翻译，其背后的思想在于，相比Java源代码，字节码更小也更容易编译，但付出的代价是需要在Java字节码编译为机器码时花上一点时间，但与直接把Java源代码编译为机器码相比，时间还是少得多的。在32位与64位的JVM中，相应的JIT在把Java字节码编译为最终的机器码时，所花的时间稍微有所不同，但还能进行一些优化；另外，在IBM与Sun这两个版本的客户端与服务端程序上，总体性能也会有所不同。 垃圾回收会收回对象不再需要使用的内存,它必须被经常执行以释放对象不再访问的Java堆。由于在32位与64位平台上，Java堆中的数据大小会有所变化，所以会因为32位与64位JVM的性能差异，然而指针越大越GC管理越困难,导致相应垃圾回收的性能也会有所不同。 


# 运用方案


# 实例

https://www.aliyun.com/jiaocheng/571366.html
https://blog.csdn.net/hong10086/article/details/79899961
https://www.csdn.net/article/2012-12-13/2812815-Should-I-use-a-32-or-a-64-bit-JVM
