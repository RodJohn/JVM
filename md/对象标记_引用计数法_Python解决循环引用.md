

“标记-清除”解决循环引用



将集合中对象的引用计数复制一份副本，改动该对象引用的副本。对于副本做任何的改动，都不会影响到对象生命走起的维护。
这个计数副本的唯一作用是寻找root object集合（该集合中的对象是不能被回收的）。
当成功寻找到root object集合之后，
首先将现在的内存链表一分为二，
一条链表中维护root object集合，成为root链表，
另外一条链表中维护剩下的对象，成为unreachable链表。
之所以要剖成两个链表，是基于这样的一种考虑：现在的unreachable可能存在被root链表中的对象，直接或间接引用的对象，这些对象是不能被回收的，一旦在标记的过程中，发现这样的对象，就将其从unreachable链表中移到root链表中；当完成标记后，unreachable链表中剩下的所有对象就是名副其实的垃圾对象了，接下来的垃圾回收只需限制在unreachable链表中即可。


# 容器

在Python中, 所有能够引用其他对象的对象都被称为容器(container). 因此只有容器之间才可能形成循环引用.
Python的垃圾回收机制利用了这个特点来寻找需要被释放的对象. 为了记录下所有的容器对象, Python将每一个 容器都链到了一个双向链表中, 之所以使用双向链表是为了方便快速的在容器集合中插入和删除对象. 有了这个 维护了所有容器对象的双向链表以后, Python在垃圾回收时使用如下步骤来寻找需要释放的对象:

对于每一个容器对象, 设置一个gc_refs值, 并将其初始化为该对象的引用计数值.
对于每一个容器对象, 找到所有其引用的对象, 将被引用对象的gc_refs值减1.
执行完步骤2以后所有gc_refs值还大于0的对象都被非容器对象引用着, 至少存在一个非循环引用. 因此 不能释放这些对象, 将他们放入另一个集合.
在步骤3中不能被释放的对象, 如果他们引用着某个对象, 被引用的对象也是不能被释放的, 因此将这些 对象也放入另一个集合中.
此时还剩下的对象都是无法到达的对象. 现在可以释放这些对象了.


# 参考

https://www.cnblogs.com/Leon-The-Professional/p/10137405.html  
http://python.jobbole.com/88827/
