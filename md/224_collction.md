

# 标记清除算法

概念

    Mark-Sweep（标记-清除）

原理

    标记出所有存活的对象，
    回收未被标记的对象所占用的空间

图解

![](https://github.com/RodJohn/JVM/blob/master/img/gcmarksweep.jpg)
    
优点

    实现简单
    不需要复制或者移动内存而产生STW     
    
缺点

    容易产生内存碎片，
    碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。    
    
运用

    适用于对象存活率高的情况    
    
# 复制算法

概念
 
    Copying（复制）算法

原理

    将可用内存按容量划分两块，每次只使用其中的一块。
    当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，


图解

![](https://github.com/RodJohn/JVM/blob/master/img/gccopy.jpg)

优点

    解决内存碎片问题
    
缺点

    能使用的内存缩减到原来的一半。
    
    Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。
    当大量对象存活时，需要大量的内存复制
    
    移动对象将STW
    
运用

    适用于对象存活率低的情况
    
    
# 标记整理算法

概念

    Mark-Compact（标记-整理）算法
    
原理

    标记出所有存活的对象，
    将存活对象都向一端移动，然后清理掉端边界以外的内存
    
图解

![](https://github.com/RodJohn/JVM/blob/master/img/gcmarkcompact.jpg)

优点
  
    解决了内存碎片问题，
    比复制算法空间利用率高。

缺点

    移动对象将STW
    


