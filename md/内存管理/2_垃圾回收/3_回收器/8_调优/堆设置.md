
堆设置
    
    JVM 中最大堆大小有三方面限制: 
    1.相关操作系统的数据模型(32-bt还是64-bit)限制;
     2.系统的可用虚拟内存限制; 
     3.系统的可用物理内存限制. 在32位系统下,一般限制在1.5G~2G;64为操作系统对内存无特定限制.  
    在Windows Server 2003 系统,3.5G物理内存,JDK5.0下测试,最大可设置为1478m.



    JVM初始分配的内存由-Xms指定,默认是物理内存的1/64;
    JVM最大分配的内存由-Xmx指定,默认是物理内存的1/4.
    默认空余堆内存小于40%时,JVM就会增大堆直到-Xmx的最大限制;
    空余堆内存大于70%时, JVM会减少堆直到-Xms的最小限制.
    因此服务器一般设置-Xms,-Xmx相等以避免在每次GC 后调整堆的大小.

    -Xms:初始堆大小 
    -Xmx:最大堆大小（可与-Xmx相同，避免垃圾回收后JVM重新分配内存。）

分代

    整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.
 
 年轻代
 
     年轻代大小选择 
     响应时间优先的应用:
     尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择).
     在此种情况下,年轻代收集发生的频率也是最小的.同时,减少到达年老代的对象. (因为CMS的问题)
     
     
     
     吞吐量优先的应用:
     尽可能的设置大,可能到达Gbit的程度.
     因为对响应时间没有要求,垃圾收集可以并行进行,一般适合8CPU以上的应用.
    
    Sun官方推荐配置为整个堆的3/8
     
    -XX:NewSize=n: 设置年轻代大小
    -Xmn：设置年轻代大小（设置一处即可）
    –XX:NewRatio :设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5


年老代

    年老代大小选择 
    响应时间优先的应用:
    年老代使用并发收集器,所以其大小需要小心设置,
    一般要考虑并发会话率和会话持续时间等一些参数.
    如果堆设置小了,可以会造成内存碎 片,高回收频率以及应用暂停而使用传统的标记清除方式
    如果堆大了,则需要较长的收集时间.最优化的方案,一般需要参考以下数据获得: 
    1.并发垃圾收集信息 
    2.持久代并发收集次数 
    3.传统GC信息 
    4.花在年轻代和年老代回收上的时间比例
    5.减少年轻代和年老代花费的时间,一般会提高应用的效率
    
    吞吐量优先的应用:一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代.原因是,这样可以尽可能回收掉大部分短期对象,减少中期的对象,而年老代尽存放长期存活对象.
    较小堆引起的碎片问题
    因为年老代的并发收集器使用标记,清除算法,所以不会对堆进行压缩.当收集器回收时,他会把相邻的空间进行合并,这样可以分配给较大的对象.但是,当堆空 间较小时,运行一段时间以后,就会出现"碎片",如果并发收集器找不到足够的空间,那么并发收集器将会停止,然后使用传统的标记,清除方式进行回收.如果 出现"碎片",可能需要进行如下配置: 
    -XX:+UseCMSCompactAtFullCollection:使用并发收集器时,开启对年老代的压缩. 
    -XX:CMSFullGCsBeforeCompaction=0:上面配置开启的情况下,这里设置多少次Full GC后,对年老代进行压缩    
    

Eden、Surviver

    -XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4 
    -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示 
    Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
    
    
-XX:MaxTenuringThreshold 

    控制对象在经过多少次minor GC之后进入老年代，此参数只有在Serial 串行GC时有效。  默认值为15次  
 

永久代

    
    
    -XX:MaxPermSize=16m:
    设置持久代大小为16m。持久代一般固定大小为64m
    
    -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。
    设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6    
    
栈
    
    -Xss128k：
    设置每个线程的堆栈大小。
    JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。
    更具应用的线程所需内存大小进行调整。
    在相同物理内存下，减小这个值能生成更多的线程。
    但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。


    -XX:MaxTenuringThreshold=0：
    设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。



示例

响应优先

    java 
    -Xmx3550m -Xms3550m -Xmn2g -Xss128k 
    -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
    -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection
    
吞吐量优先
    
    java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100    