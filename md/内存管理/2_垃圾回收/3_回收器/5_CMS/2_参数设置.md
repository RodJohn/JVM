
# 空间碎片

## 缺陷

    标记清除算法的影响
    

## 解决
    
碎片整理
    
    进行Full GC时整理内存碎片
    这个过程需要STW，碎片问题解决了,但停顿时间又变长了。
    
碎片整理频率
    
    可以设置执行多少次不压缩的Full GC后，跟着来一次带压缩的
    
参数
    
    UseCMSCompactAtFullCollection 开启碎片整理
        (默认开启，但不会进行，结合下面的CMSFullGCsBeforeCompaction)，
    CMSFullGCsBeforeCompaction  设置整理频率
        (默认为0，每次进入Full GC时都进行碎片整理）。

    

# 浮动垃圾

## 浮动垃圾

    在并发清除时，用户线程新产生的垃圾，称为浮动垃圾
    这使得并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集
    可以认为CMS所需要的空间比其他垃圾收集器大；
    
## 解决

回收阈值

    设置回收阈值,
    达到百分比就进行垃圾回收。

参数
    
    CMSInitiatingOccupancyFraction 设置阈值
        JDK1.5默认值为68%；
        JDK1.6变为大约92%；

参数设置
        
    设置的太小
        会导致频繁的CMS GC，产生大量的停顿；
    设置的太高
        若用户线程申请不到足够空间，就会产生Concurrent  Mode Failure错误，
        意思就是说并发模式失败。
    
        虚拟机就会启动备案：使用Serial Old收集器重新对老年代进行垃圾回收.
        如此一来，停顿时间变得更长。
        
      
在实际情况中

    CMS是配合ParNew进行使用，
    此时新生代大小一般是堆的60%
    加长分代年龄减少对象进入老年代的速率        
    该值设置为80%
    
# 抢占CPU资源
    
## 原因

    CMS默认的回收线程数是(CPU个数+3)/4。
    当CPU大于4个时,保证回收线程占用至少25%的CPU资源
    当CPU只有2个时,保证回收线程占用50%的CPU资源
    会造成用户线程执行效率下降

## 解决

    CMS的解决方案是提供了一个 incremental mode（增量模式）。
    在这种模式下，进行并发标记、清理时让GC线程、用户线程交替运行，尽量减少GC线程独占CPU资源的时间。
    这会造成GC时间更长，但对用户线程造成的影响就会少一些。
    但实践证明，这种模式下CMS的表现很一般，并没有什么大的优化。
    但效果并不理想，JDK1.6后就官方不再提倡用户使用。



      









启用CMS：-XX:+UseConcMarkSweepGC





