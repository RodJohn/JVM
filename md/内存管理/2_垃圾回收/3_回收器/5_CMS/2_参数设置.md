
# 空间碎片

## 原因

    使用标记-清除算法可能造成大量的空间碎片。
    空间碎片过多，无法找到足够大的连续空间来分配当前对象,不得不触发一次Full GC。

## 解决
    
    CMS的解决方案是使用UseCMSCompactAtFullCollection参数(默认开启，但不会进行，结合下面的CMSFullGCsBeforeCompaction)，
    在进行Full GC，而整理内存碎片；
    这个过程需要STW，碎片问题解决了,但停顿时间又变长了。
    
    虚拟机还提供了另外一个参数CMSFullGCsBeforeCompaction，
    用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的
    （默认为0，每次进入Full GC时都进行碎片整理）。

    由于空间不再连续，CMS需要使用可用"空闲列表"内存分配方式，这比简单实用"碰撞指针"分配内存消耗大；

# 浮动垃圾

## 浮动垃圾

    在并发清除时，用户线程新产生的垃圾，称为浮动垃圾
    这使得并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集
    可以认为CMS所需要的空间比其他垃圾收集器大；
    
## 回收阈值

    CMS 提供了CMSInitiatingOccupancyFraction参数来设置老年代空间使用百分比,
    达到百分比就进行垃圾回收。
    
    JDK1.5默认值为68%；
    JDK1.6变为大约92%；
    
    设置的太小
        会导致频繁的CMS GC，产生大量的停顿；
    设置的太高
        若用户线程申请不到足够空间，就会产生Concurrent  Mode Failure错误，
        意思就是说并发模式失败。
    
        虚拟机就会启动备案：使用Serial Old收集器重新对老年代进行垃圾回收.
        如此一来，停顿时间变得更长。
        
        
    缓慢增长 设高 （合理）
    增长迅速设低 （让新生代控制）        
    
    浮动垃圾不会太多
    设为68
    
# 抢占CPU资源
    
## 原因

    CMS默认的回收线程数是(CPU个数+3)/4。
    当CPU大于4个时,保证回收线程占用至少25%的CPU资源
    当CPU只有2个时,保证回收线程占用50%的CPU资源
    会造成用户线程执行效率下降

## 解决

    我给的答案是可以不用考虑这种场景。现在的PC机中都至少有双核处理器，更别说大型的服务器了。
    
    CMS的解决方案是提供了一个 incremental mode（增量模式）。
    在这种模式下，进行并发标记、清理时让GC线程、用户线程交替运行，尽量减少GC线程独占CPU资源的时间。
    这会造成GC时间更长，但对用户线程造成的影响就会少一些。
    但实践证明，这种模式下CMS的表现很一般，并没有什么大的优化。
    但效果并不理想，JDK1.6后就官方不再提倡用户使用。



      









启用CMS：-XX:+UseConcMarkSweepGC





