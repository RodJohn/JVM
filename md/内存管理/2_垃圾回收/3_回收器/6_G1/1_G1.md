  
  
# 参考

https://tech.meituan.com/2016/09/23/g1.html
    

# 概念

    G1，Garbage First，
    在JDK 1.7版本正式启用，是当时最前沿的垃圾收集器。
    Garbage First Collector的使命是在未来替换CMS，并且在JDK1.9已经成为默认的收集器。
    G1可以说是CMS的终极改进版，解决了CMS内存碎片、更多的内存空间登问题。
    虽然流程与CMS比较相似，但底层的原理已是完全不同
    

# 定位

    全代收集器
    低延时收集器
    可控收集器 
    最大量回收   
    超大堆
 
 
# 适用情况

 多核，6G以上的heap


# 技术特点

G1是一种并发、并行、部分Stop The World、使用Copying算法收集的分代的增量式收集器， 
 
# 设计


# 对象分配策略
  
  说起大对象的分配，我们不得不谈谈对象的分配策略。它分为3个阶段：
  
  TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区
  Eden区中分配
  Humongous区分配
  TLAB为线程本地分配缓冲区，它的目的为了使对象尽可能快的分配出来。如果对象在一个共享的空间中分配，我们需要采用一些同步机制来管理这些空间内的空闲空间指针。在Eden空间中，每一个线程都有一个固定的分区用于分配对象，即一个TLAB。分配对象时，线程之间不再需要进行任何的同步。
  
  对TLAB空间中无法分配的对象，JVM会尝试在Eden空间中进行分配。如果Eden空间无法容纳该对象，就只能在老年代中进行分配空间。
  
  
      
    
# 流程

 
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
# 原理



Remembered Set
 
    但是这样同样会引申一个新的问题，就是分代的内存不连续，导致在GC搜索垃圾对象的时候需要全盘扫描找出引用内存所在。
    为了解决这个问题，G1对于每个Region都维护一个Remembered Set，用于记录对象引用的情况。当GC发生的时候根据Remembered Set的引用情况去搜索。


        
## 流程

    整体的执行流程：
    
    初始标记（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。
    并发标记（concurrent marking），并发标记初始标记的对象，此时用户线程依然可以执行。
    最终标记（Remark），STW，标记再并发标记过程中产生的垃圾。
    筛选回收（Live Data Counting And Evacuation），评估标记垃圾，根据GC模式回收垃圾。STW执行。
    
    
 
 
 # CMS VS G1
 
 G1虽然保留了CMS关于代的概念，
 但是代已经不是物理上连续区域，而是一个逻辑的概念。
 在标记过程中，每个区域的对象活性都被计算，
 在回收时候，就可以根据用户设置的停顿时间，选择活性较低的区域收集，这样既能保证垃圾回收，又能保证停顿时间
 ，而且也不会降低太多的吞吐量。Remark阶段新算法的运用，以及收集过程中的压缩，都弥补了CMS不足
 
 
 

# 使用

    首先，G1的设计原则就是简单可行的性能调优
    开发人员仅仅需要声明以下参数即可：
    -XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200
    
    其中-XX:+UseG1GC为开启G1垃圾收集器，-Xmx32g 设计堆内存的最大内存为32G，-XX:MaxGCPauseMillis=200设置GC的最大暂停时间为200ms。如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可。


# G1将新生代，老年代的物理空间划分取消了

    不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够
    
    G1算法将堆划分为若干个区域（Region），
    它仍然属于分代收集器。
    不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。
    老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了
    
    在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。
    
    
    
# G1 Young GC

    Young GC主要是对Eden区进行GC，
    它在Eden空间耗尽时会被触发。
    Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。
    Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。
    最终Eden空间的数据为空，GC停止工作，应用线程继续执行。

Remembered Set

    作用是跟踪指向某个heap区内的对象引用

    在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，
    在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。
    
    RememberedSet 

RememberedSet 用于处理这类问题：比如说，新生代 gc （它发生得非常频繁）。一般来说， gc 过程是这样的：首先枚举根节点。根节点有可能在新生代中，也有可能在老年代中。这里由于我们只想收集新生代（换句话说，不想收集老年代），所以没有必要对位于老年代的 GC Roots 做全面的可达性分析。但问题是，确实可能存在位于老年代的某个 GC Root，它引用了新生代的某个对象，这个对象你是不能清除的。那怎么办呢？ 

仍然是拿空间换时间的办法。事实上，对于位于不同年代对象之间的引用关系，虚拟机会在程序运行过程中给记录下来。对应上面所举的例子，“老年代对象引用新生代对象”这种关系，会在引用关系发生时，在新生代边上专门开辟一块空间记录下来，这就是 RememberedSet 。所以“新生代的 GC Roots ” + “ RememberedSet 存储的内容”，才是新生代收集时真正的 GC Roots 。然后就可以以此为据，在新生代上做可达性分析，进行垃圾回收。 

我们知道， G1 收集器使用的是化整为零的思想，把一块大的内存划分成很多个域（ Region ）。但问题是，难免有一个 Region 中的对象引用另一个 Region 中对象的情况。为了达到可以以 Region 为单位进行垃圾回收的目的， G1 收集器也使用了 RememberedSet 这种技术，在各个 Region 上记录自家的对象被外面对象引用的情况。



    
point-in
        
    但在G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的分区引用也扫描了。于是G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。
    需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1 中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址。默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。

   
参考

    http://blog.jobbole.com/109170/    
