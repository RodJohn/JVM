

# 工作流程

新生代垃圾收集
后台收集、并发周期
混合式垃圾收集
必要时候的Full GC


# 新生代收集

## 特点
         
     多线程并行STW
     可控
        通过控制新生代的数量达到GC停顿可控
        
## 过程
触发

    当Eden区不能再分配新的对象时就会触发。  
标记

    整个新生代     
清理

    将存活对象复制到一个或多个Survivor区，
    若对象年龄达到了阈值，则会被晋升至老年代(ParNew默认15)。
    该过程是Stop-The-World的，
    
预测？
    
    根据垃圾收集统计信息及用户定义的暂停时间目标等
    调整年轻代的region个数，来控制young GC的时间开销
    

# 并发标记

## 目的

    它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节
    并发标记周期采用的算法是我们前文提到的SATB标记算法，产出是找出一些垃圾对象最多的老年代分区。

## 流程


触发

    堆使用到达阈值(InitiatingHeapOccupancyPercent，默认值是45)

特点

    并发收集周期中，至少有一次（很可能是多次）新生代垃圾收集；


初始标记（initial-mark）

    设置TAMS标记，所有在TAMS之上的对象在这个并发周期内会被识别为隐式存活对象

    在这个阶段，应用会经历STW，
    
    通常初始标记阶段会跟一次新生代收集一起进行，
    换句话说——既然这两个阶段都需要暂停应用，G1 GC就重用了新生代收集来完成初始标记的工作。
    在新生代垃圾收集中进行初始标记的工作，会让停顿时间稍微长一点，并且会增加CPU的开销。


根分区扫描（root-region-scan）


    在初始标记或新生代收集中被拷贝到survivor分区的对象，都需要被看做是根，

    这个过程不需要暂停应用，

    正因为这个，该阶段不能发生新生代收集，
    如果扫描根分区时，新生代的空间恰好用尽，新生代垃圾收集必须等待根分区扫描结束才能完成。
    如果在日志中发现根分区扫描和新生代收集的日志交替出现，就说明当前应用需要调优。


并发标记阶段（concurrent-mark）


    并发标记会利用trace算法找到所有活着的对象
    因为在TAMS之上的对象都被视为隐式存活，因此我们只需要遍历那些在TAMS之下的；
    记录在标记的时候发生的引用改变

    并发标记阶段是多线程的

重新标记阶段（remarking）

    需要暂停整个应用，
    G1垃圾收集器会处理掉剩下的SATB日志缓冲区和所有更新的引用，
    同时G1垃圾收集器还会找出所有未被标记的存活对象。

清理阶段（cleanup）
    
    标记处哪些老年代分区可以回收，将老年代按照它们的存活度（liveness）从小到大排列。
    这个过程还会做几个事情：识别出所有空闲的分区、RSet梳理、将不用的类从metaspace中卸载、回收巨型对象等等。
    识别出每个分区里存活的对象有个好处是在遇到一个完全空闲的分区时，它的RSet可以立即被清理，
    同时这个分区可以立刻被回收并释放到空闲队列中，而不需要再放入CSet等待混合收集阶段回收；


# Mixed GC

    混合收集只会回收一部分老年代分区，而且会执行多次，
    一直运行到（几乎）所有标记点老年代分区都被回收，


# 运行图

![](https://github.com/RodJohn/jvm/blob/master/img/G1Process.png)

# Full GC

    G1的垃圾回收过程是和应用程序并发执行的，
    当Mixed GC的速度赶不上应用程序申请内存的速度的时候，Mixed G1就会降级到Full GC，使用的是Serial GC
    导致G1 Full GC的原因可能有两个：
    Evacuation的时候没有足够的to-space来存放晋升的对象；
    并发处理过程完成之前空间耗尽


# 参考

https://hllvm-group.iteye.com/group/topic/44381?page=3  

