
 # Serial Old 
 
作用
 
    老年代收集器
    
特点

    使用标记整理算法
    使用单线程 
    收集时暂停所有用户进程
    
    
适用情况

    Client模式下的虚拟机使用。
    在Server模式下，作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。
    
    
# Parallel Old


作用

    老年代收集器
    
特点

    
    采用多线程
    采用”标记－整理”算法
    关注吞吐量
    
适用情况
    
    Parallel Old收集器是Parallel Scavenge收集器的老年代版本，
    在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。   
    
    
# CMS

![](https://github.com/RodJohn/JVM/blob/master/img/gccms.png)

作用

    老年代收集器
    
特点

    使用标记清除算法
    关注最短回收停顿时间   
    由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。
    工作流程
        初始标记(initial mark)：找GC Roots
        并发标记(concurrent mark)：找引用链
        重新标记(remark)：查找变更
        并发清除(concurrent sweep)：清除
        注意初始标记和重新标记还是会stop the world，
        但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。                      
     
 
缺点

    基于标记清除算法实现的，会导致有大量的空间碎片产生，
        在为大对象分配内存的时候，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前开启一次Full GC。
        为了解决这个问题，CMS收集器默认提供了一个-XX:+UseCMSCompactAtFullCollection收集开关参数（默认就是开启的)，
        用于在CMS收集器进行FullGC完开启内存碎片的合并整理过程，内存整理的过程是无法并发的，这样内存碎片问题倒是没有了，不过停顿时间不得不变长。
        虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction参数用于设置执行多少次不压缩的FULL GC后跟着来一次带压缩的
        （默认值为0，表示每次进入Full GC时都进行碎片整理）。     
        
    对cpu资源敏感
        垃圾收集线程数和每个收集线程占用cpu的时间受cpu数量影响
    
    无法处理“浮动垃圾”
        即并发清除阶段用户线程又产生的对象。
        -XX:CMSInitiatingOccupancyFranction：老年代被使用的百分比，达到时触发GC（如果等老年代占满了再GC，则GC时并发产生的对象可能就获取不到存储空间）
        CMSInitiatingOccupancyFranction过高会导致大量Concurrent Mode Failure，即老年代预留的内存无法满足程序需要。
        

    有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢？
    答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“Stop the World”这种场景下使用。
    
    
    a>.CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。
    CMS默认启动的回收线程数是：(CPU数量+3) / 4。b>.CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure“，失败后而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。
    这一部分垃圾称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分内存空间提供并发收集时的程序运作使用。
    在默认设置下，CMS收集器在老年代使用了68%的空间时就会被激活，也可以通过参数-XX:CMSInitiatingOccupancyFraction的值来提供触发百分比，以降低内存回收次数提高性能。要是CMS运行期间预留的内存无法满足程序其他线程需要，就会出现“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置的过高将会很容易导致“Concurrent Mode Failure”失败，性能反而降低。c>.最后一个缺点，CMS是基于“标记-清除”算法实现的收集器，使用“标记-清除”算法收集后，会产生大量碎片。空间碎片太多时，将会给对象分配带来很多麻烦，比如说大对象，内存空间找不到连续的空间来分配不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:UseCMSCompactAtFullCollection开关参数，用于在Full GC之后增加一个碎片整理过程，还可通过-XX:CMSFullGCBeforeCompaction参数设置执行多少次不压缩的Full GC之后，跟着来一次碎片整理过程。
