
@[TOC]


# 栈上分配

概念

	直接在java栈上给对象分配空间，而不是堆中
	
好处

	栈上分配的对象可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入




# 逃逸分析

关系

	栈上分配的基础是进行逃逸分析，
	单逃逸分析的好处不仅仅是栈上分配

概念

	逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；
	这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收，由于其被其它变量引用。
	正常的方法调用中，方法体中创建的对象将在执行完毕之后，将回收其中创建的对象；故由于无法回收，即成为逃逸。

好处

	栈上分配
	消除同步
		线程同步的代价是相当高的，同步的后果是降低并发性和性能。
		逃逸分析可以判断出某个对象是否始终只被一个线程访问，
		如果只被一个线程访问，那么对该对象的同步操作就可以转化成没有同步保护的操作。
	矢量替代。
		逃逸分析方法如果发现对象的内存存储结构不需要连续进行的话，
		就可以将对象的部分甚至全部都保存在CPU寄存器内，这样能大大提高访问速度。


# 运用

	只能在server模式下才能启用逃逸分析，
	参数-XX:DoEscapeAnalysis启用逃逸分析，
	参数-XX:+EliminateAllocations开启标量替换（默认打开）。
	在JDK 6u23版本之后，HotSpot中默认就开启了逃逸分析，可以通过选项-XX:+PrintEscapeAnalysis查看逃逸分析的筛选结果。
	  在JDK 6之后支持对象的栈上分析和逃逸分析，在JDK 7中完全支持栈上分配对象



# 示例

代码

```
    private static class Foo {
        private Integer i = new Integer(5);
    }

    public static void main(String[] args) {
        long start = System.nanoTime();
        for (int i = 0; i < 1000 * 1000 * 10; ++i) {
            Foo foo = new Foo();
        }
        long end = System.nanoTime();
        System.out.println("Time cost is " + (end - start));
    }

```

测试参数

	开启逃逸分析
		-server -verbose:gc -XX:+DoEscapeAnalysis（部分版本默认开启）
	关闭逃逸分析
		-server -verbose:gc -XX:-DoEscapeAnalysis

测试结果

	关闭逃逸
		[GC (Allocation Failure)  33280K->784K(125952K), 0.0008923 secs]
		[GC (Allocation Failure)  34064K->800K(125952K), 0.0008482 secs]
		[GC (Allocation Failure)  34080K->752K(125952K), 0.0005642 secs]
		[GC (Allocation Failure)  34032K->752K(159232K), 0.0009449 secs]
		[GC (Allocation Failure)  67312K->704K(159232K), 0.0009999 secs]
		[GC (Allocation Failure)  67264K->720K(221696K), 0.0010205 secs]
		Time cost is 77859583
	打开逃逸
		Time cost is 5886059

拓展测试

|循环次数| 1000 * 1000 * 10 |1000 * 1000  | 1000 * 10 |
|--|--|--|--|
| 开启逃逸| 5，886，059 |6，050，589|1，516，535|
| 关闭逃逸|  77，859，583（GC6次）|18，737，420（GC1次）|1，881，051|


# 参考

https://blog.csdn.net/yangzl2008/article/details/43202969#




# 栈上分配
  
    在JVM中，堆是线程共享的，因此堆上的对象对于各个线程都是共享和可见的，只要持有对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但对于垃圾收集器来说，无论筛选可回收对象，还是回收和整理内存都需要耗费时间。
    
    如果确定一个对象的作用域不会逃逸出方法之外，那可以将这个对象分配在栈上，这样，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，无须通过垃圾收集器回收，可以减小垃圾收集器的负载。
    
    JVM允许将线程私有的对象打散分配在栈上，而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统性能。  
    栈上分配的技术基础： 
    一是逃逸分析：逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。关于逃逸分析的问题可以看我另一篇文章：
    
    二是标量替换：允许将对象打散分配在栈上，比如若一个对象拥有两个字段，会将这两个字段视作局部变量进行分配。 
    
    只能在server模式下才能启用逃逸分析，参数-XX:DoEscapeAnalysis启用逃逸分析，参数-XX:+EliminateAllocations开启标量替换（默认打开）。Java SE 6u23版本之后，HotSpot中默认就开启了逃逸分析，可以通过选项-XX:+PrintEscapeAnalysis查看逃逸分析的筛选结果。
    
    https://blog.csdn.net/yangzl2008/article/details/43202969
 
