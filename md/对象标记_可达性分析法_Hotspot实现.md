
# 安全点

枚举根节点STW

    可达性分析法第一步是枚举根节点，  
    为了保证枚举期间对象引用不再变化，必须先暂停程序的执行（STW），  
    根节点一般是全局引用和栈上本地变量，  
    如果对全部内存扫描一遍，则将长时间暂停线程  

OopMap

    HotSpot在类加载和JIT编译  
    使用OopMap来记录对象中引用的位置    
    这样就可以快速的完成GC Roots枚举


安全点

    导致引用变化的指令很多，而且如果给每次引用变化都保存对应的OopMap，会造成大量额外的空间  
    所以HotSpot只会在“特定的位置”生成对应的OopMap，这些位置就成为“安全点”

安全区域

	safe region是指一块区域，这块区域中的引用都不会被修改，
	比如线程被阻塞了，那么它的线程堆栈中的引用是不会被修改的，JVM可以安全地进行标记。
	线程进入到safe region的时候先标识自己进入了safe region，
	等它被唤醒准备离开safe region的时候，先检查能否离开，
	如果GC已经完成，那么可以离开，否则就在safe region呆在。

注意

	JVM在很多场景下使用到safepoint, 最常见的场景就是GC的时候
	

# GC和安全点

## 时机

    HotSpot也并不是任何时刻都会停顿下来进行GC，只会在程序都到底安全点之后才会GC，  
    所以安全点的设置要保证程序执行时不需要太长时间就可以进入一个安全点进行 GC 动作

## 中断方式

抢断式中断  

    不需要线程的执行代码去主动配合，当发生GC时，先强制中断所有线程，    
    然后如果发现某些线程未处于安全点，恢复程序运行，直到进入安全点为止。

主动式中断

    设置一个中断标记，各个线程在执行时轮询这个标记，  
    一旦发现标记被改变(出现中断标记)时，那么将运行到安全点后自己中断挂起。  
    目前所有商用虚拟机全部采用主动式中断。


# 拓展

	但是安全点的作用不单单是GC

	https://blog.csdn.net/ITer_ZC/article/details/41847887




# 参考

https://dsxwjhf.iteye.com/blog/2201685  
