
# STW

  垃圾回收流程： 
  
  Java虚拟机在内存回收之前，为了保证内存的一致性，必须先暂停程序的执行，也就是传说中的Stop The World（简称STW），
  在使用可达性分析算法枚举GC Roots，标记出死亡对象，再进行垃圾回收。
  垃圾回收遇到的问题： 
  
  那既然是要暂停程序的运行，就一定要保证停止的时间足够短，并且可控，不然带来的灾难将是毁灭性的。


# OopMap

HotSpot在设计的时候也考虑到了这个问题  
所以在JIT编译的时候就会使用OopMap数据结构来记录栈和寄存器上的引用，  
这样虚拟机就直接知道了那些地方存放着对象的引用，  
如下图，为我编译String.hashCode()方法的部分本地代码：

# 安全点（Safepoint）

在OopMap的协助下，HotSpot可以快速的完成GC Roots枚举，
但导致OopMap内容变化的指令很多，而且如果给每个对象生成对应的OopMap，会造成大量额外的空间，这会导致GC成本很高，
所以HotSpot只会在“特定的位置”生成对应的OopMap，这些位置就成为“安全点”。
HotSpot也并不是任何时刻都会停顿下来进行GC，只会在程序都到底安全点之后才会GC，
所以安全点的设置不能太少，让GC等待时间太长，也不能太多增大运行时的成本。

安全点的两种线程中断方式
抢断式中断：不需要线程的执行代码去主动配合，当发生GC时，先强制中断所有线程，然后如果发现某些线程未处于安全点，恢复程序运行，直到进入安全点为止。
主动式中断：不强制中断线程，只是简单地设置一个中断标记，各个线程在执行时轮询这个标记，一旦发现标记被改变(出现中断标记)时，那么将运行到安全点后自己中断挂起。目前所有商用虚拟机全部采用主动式中断。

# 安全区域（Saferegion）

安全点机制仅仅是保证了程序执行时不需要太长时间就可以进入一个安全点进行 GC 动作，但是当特殊情况时，比如线程休眠、线程阻塞等状态的情况下，显然HotSpot不可能一直等待被阻塞或休眠的线程正常唤醒执行；此时就引入了安全区的概念。
安全区(Saferegion)：安全区域是指在一段区域内，对象引用关系等不会发生变化，在此区域内任意位置开始GC都是安全的；线程运行时，首先标记自己进入了安全区，然后在这段区域内，如果线程发生了阻塞、休眠等操作，HotSpot发起GC时将忽略这些处于安全区的线程。当线程再次被唤醒时，首先他会检查是否完成了GC Roots枚举(或这个GC过程)，如果完成了就继续执行，否则将继续等待直到收到可以安全离开的Safe Region的信号为止。

3、HotSpot的GC算法实现：
（1）HotSpot怎么快速找到GC Root？
HotSpot使用一组称为OopMap的数据结构。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在栈和寄存器中哪些位置是引用。这样子，在GC扫描的时候，就可以直接知道哪些是可达对象了。
（2）安全点：
A、HotSpot只在特定的位置生成OopMap，这些位置称为安全点。
B、程序执行过程中并非所有地方都可以停下来开始GC，只有在到达安全点是才可以暂停。
C、安全点的选定基本上以“是否具有让程序长时间执行“的特征选定的。比如说方法调用、循环跳转、异常跳转等。具有这些功能的指令才会产生Safepoint。
（3）中断方式：
A、抢占式中断：在GC发生时，首先把所有线程中断，如果发现有线程不在安全点上，就恢复线程，让它跑到安全点上。
B、主动式中断：GC需要中断线程时，不直接对线程操作，仅仅设置一个标志，各个线程执行时主动去轮询这个标志，当发现中断标记为真就自己中断挂起。轮询标记的地方和安全点是重合的。

（5）安全区域：一段代码片段中，对象的引用关系不会发生变化，在这个区域中任何地方开始GC都是安全的。在线程进入安全区域时，它首先标志自己已经进入安全区域，在这段时间里，当JVM发起GC时，就不用管进入安全区域的线程了。在线程将要离开安全区域时，它检查系统是否完成了GC过程，如果完成了，它就继续前行。否则，它就必须等待直到收到可以离开安全区域的信号。
4、 GC时为什么要停顿所有Java线程？
因为GC先进行可达性分析。可达性分析是判断GC Root对象到其他对象是否可达，假如分析过程中对象的引用关系在不断变化，分析结果的准确性就无法得到保证。



