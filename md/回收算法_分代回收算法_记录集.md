

# 对象标记

    新生代GC，
    如果从根直接进行可达性分析,则每次都得扫描老年代对象
    (可达性分析法的效率和存活率成正比，老年代存活率很高，所以要浪费很多时间)
    年轻代回收的时候, 首先找出 root 对象, 然后对于从老年代到年轻代的引用, 可以有下面几种方式来发现老年代到年轻代的引用:

    从 root 对象开始找到从老年代到年轻代的引用关系 - 比较耗时, 相当于整个 heap 都做引用关系图;
    忽略 root 对象, 扫描所有老年代对象, 然后找到从老年代到年轻代的引用 - 也挺多的.


# 记录集

    记录集记录了老年代对象到新生代对象的引用
    新生代 GC 时，从记录集和根直接引用的新生代对象开始搜索
    就避免了对老年代的扫描
    
![](https://github.com/RodJohn/jvm/blob/master/img/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E9%9B%861.png)    
    
    
    记录集里记录是老年代对象
    point out记录发出引用的对象
    
    
![](https://github.com/RodJohn/jvm/blob/master/img/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E9%9B%862.png)    
    
    
    
# 写入屏障

将老年代对象记录到记录集里，我们利用写入屏障(write barrier)

# CardTable

    对老年代 heap 设立一个 dirty card 表. 
    例如对老年代每256K 映射到 dirty card 中的一个 bit,
    如果老年代有对年轻代的引用的时候(老年代对象字段值的修改), 把这个 bit 修改代表 dirty.






# 参考

https://www.jianshu.com/p/5037459097ee  

