
# 双亲委派
    
    如果一个类加载器收到了类加载的请求，
    首先自己不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，
    所有的加载请求最终都被传送到顶层的启动类加载器中，父类无法完成加载时，子类加载。
	
![](https://github.com/RodJohn/JVM/blob/master/img/ClassLoder.png)	

# 作用

唯一性

	确保每个加载器只能加载自己范围内的类；
    保证类的统一性

原理

    只有在满足如下三个类“相等”判定条件，才能判定两个类相等。
    1、两个类来自同一个Class字节流
    2、两个类是由同一个虚拟机加载
    3、两个类是由同一个类加载器加载


# 原理

	ClassLoader的loadClass方法实现了双亲委派的算法，
	先从缓存中查找该类对象，
	然后交给该类加载去的父加载器去加载，
	最后使用findClass()方法去加载
	
```

 protected Class<?> loadClass(String name, boolean resolve)hrows ClassNotFoundException
   {
      synchronized (getClassLoadingLock(name)) {
          // First, check if the class has already been loaded
             Class c = findLoadedClass(name);
              if (c == null) {
                    try {
                         if (parent != null) {
                             c = parent.loadClass(name, false);
                          } else {
                             c = findBootstrapClassOrNull(name);
                               }
                           } catch (ClassNotFoundException e) {
                                // ClassNotFoundException thrown if class not found
                                // from the non-null parent class loader
                            }
                return c;
                   }
              }
```
