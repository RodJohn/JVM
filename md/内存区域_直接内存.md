
# 直接内存

概念

    直接内存（Direct Memory）
    也叫堆外内存
	或者本地内存（Native Memory）
    直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，
    但是会被JVM虚拟机频繁用到	

作用

优点 和 零拷贝

    直接内存是
	减少数据复制，直接可以操作进程外的内存

	程序直接从操作系统中分配直接内存，
	避免了在Java堆和Native堆中来回复制数据。

	非直接内存作用链: 
		本地IO –>直接内存–>非直接内存–>直接内存–>本地IO 
	直接内存作用链: 
		本地IO–>直接内存–>本地IO
		
    堆外内存的优势
堆外内存优势在 IO 操作上，对于网络 IO，使用 Socket 发送数据时，能够节省堆内存到堆外内存的数据拷贝，所以性能更高。看过 Netty 源码的同学应该了解，Netty 使用堆外内存池来实现零拷贝技术。对于磁盘 IO 时，也可以使用内存映射，来提升性能。
另外，更重要的几乎不用考虑堆内存烦人的 GC 问题。


特点

	直接内存的空间分配比较耗时
	但是读取效率高

	它直接从操作系统中分配，因此不受Java堆大小的限制，
	但是会受到本机总内存的大小及处理器寻址空间的限制，
	因此它也可能导致OutOfMemoryError异常出现。


    JVM在运行时会自动调整元空间大小，不必担心内存设置的过小或者过大。
    提高Full GC的性能，在Full GC期间，Metadata到Metadata pointers之间不需要扫描了；

缺点

    如果程序存在内存泄露
    不停的扩展metaspace的空间，会导致机器的内存不足。
    
    
直接内存使用场景

	有很大的数据需要存储，它的生命周期很长
	适合频繁的IO操作，例如网络并发场景	
    
    
    
1 非Java堆的回收不收java yong gc的影响，一般需要手工进行回收。如果大量的使用非Java堆，则丢失了Java 自动垃圾回收的特点。

   一般使用非Java堆进行和外界通讯，并且做为缓存使用。如DirectByteBuffer。



内存

    内存大小受系统限制
    

# 实验

	纵坐标表示需要的时间


操作IO时，
比如将磁盘上的文件通过网络发送到客户端
硬盘->系统->jvm->系统->网络
4次的上下文切换
2次的数据拷贝


linux sendfile 
操作系统级别的零拷贝
需要系统支持

内存映射文件

transferTo 
linux零拷贝
https://www.cnblogs.com/pengdonglin137/articles/7995528.html


参考
图片和数据来源

https://www.cnblogs.com/xing901022/p/5243657.html
