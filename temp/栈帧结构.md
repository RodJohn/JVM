# 栈 栈帧

栈帧（Stack Frame）

    栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，
    它是虚拟机运行时数据区中的虚拟机栈（Visual Machine Stack）的栈元素。
    每个方法在执行的时候都会创建一个栈帧，
    用于存储局部变量表，操作数栈，动态连接，方法返回地址等信息。栈帧被分配到的内存空间，不受到程序运行期变量数据的影响，仅仅取决于具体的虚拟机实现。


# 局部变量表

作用

    用于存放方法参数和方法内部定义的局部变量。

容量

    在 java程序编译为Class 文件时，
    就在方法的Code属性的max_locals 数据项中确定了该方法所需要分配的局部变量表的最大容量。

变量类型

    虚拟机使用局部变量表完成参数值到参数变量列表的传递过程的，
    局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，
    在方法中可以通过关键字this来访问到这个隐含的参数。
    其余参数按照参数表顺序排序，
    占用从1开始的局部变量 Slot，参数表分配完毕后，
    再根据方法体内部定义的变量顺序和作用域分配其余的 Slot。
    
局部变量

    局部变量不存在准备阶段
    
    如果一个局部变量定义了但没有赋初始值是不能使用的，
    不要认为java中任何情况下都存在诸如整型变量默认为0，布尔变量默认为false等默认值。
 

# slot

    局部变量表容量是以变量槽（Slot）为最小单位，
    虚拟机规范中并没有明确指明一个Slot 应占用的内存空间大小，
    只是很有导向性地说到每个Slot都应该能够存放一个 boolean，byte，char，short，int，float，reference，returnAddress 类型的数据，
    这8种数据类型，都可以使用32位或更小的物理内存来存放。、
    它允许Slot的长度可以随着处理器、操作系统或虚拟机的不同而发生变化。
    

   
    
# Slot 重用

概念

    局部变量中，
    如果当前字节码PC计数器的值已经超出了某个变量的作用域，
    那这个变量对应的Slot 就可以交给其他变量使用了。
    这样可减少总栈帧空间 
    

示例和优化

```
public static void main(String[] args)() {
    byte[] placeholder = new byte[64 * 1024 * 1024];
    System.gc();
}

因为在执行System.gc() 时，变量placeholder 还处于作用域内，虚拟机自然不会回收其内存


public static void main(String[] args)() {
    {
        byte[] placeholder = new byte[64 * 1024 * 1024];
    }
    System.gc();
}

代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占用的Slot还没有被其他变量所复用，所以作为 GC Roots 一部分的局部变量仍然保持着对它的关联。


public static void main(String[] args)() {
    {
        byte[] placeholder = new byte[64 * 1024 * 1024];
    }
    int a = 0;
    System.gc();
}


public static void main(String[] args) {
    byte[] placeholder = new byte[64 * 1024 * 1024];
    placeholder = null;
    System.gc();
}

public static void main(String[] args) {
    show();
    System.gc();
}

private static void show() {
    byte[] placeholder =  new byte[64 * 1024 * 1024];
}

通过变量的作用域来控制

```

    以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法。
        创建子方法-快速回收栈帧
    
    从执行角度讲：使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的；而赋null值的操作在经过 JIT 编译优化后就会被消除掉，这时候将变量设置为null就是没有意义的。

# 操作数栈

作用

    Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”是操作数栈
    虚拟机把操作数栈作为它的工作区
    大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。
    比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中，

    是一个后入先出栈。
    操作数栈的最大深度在编译的时候写入到 Code属性的max_stacks 数据项中

作业流程




栈帧之间的数据共享

    在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。
    但在大多虚拟机实现会做一些优化，令两个栈帧出现一部分重叠。
    让下面的栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，无需进行额外的参数复制传递。           
    

# 动态连接
    
    （1）作用
    
    每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
    
    （2）静态解析
    
    在前面几篇博文的讲解中学习了Class文件的常量池中存在大量符号引用，字节码的方法调用指令就以常量池中指向方法的符号作为参数。
    
    这些符号引用一部分会在类加载阶段或第一次使用的时候就转化为直接引用，这种转化称为静态解析；
    
    （3）动态连接
    
    另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。
    
#方法返回地址

    （1）退出正执行的方法
    
    当一个方法执行后，有两种方式退出这个方法：
    
    正常完成出口（Normal Method Invocation Completion）：执行引擎遇到任意一个方法返回的字节码指令，这种退出方法称为正常完成出口。
    
    异常完成出口（Abrupt Method Invocation Completion）：在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是java虚拟机内部产生的异常，还是代码中使用athrow 字节码指令产生的异常。只要在本方法的异常表中没有搜索到匹配的异常处理器，方法就会退出；这种方式称为异常完成出口。
    
    （2）退出方法时可能执行的操作
    
    方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：
    
    恢复上层方法的局部变量表和操作数栈；
    把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。
