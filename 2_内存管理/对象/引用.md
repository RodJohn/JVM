
# 对象和引用

new Object()

    来产生一个新的对象，
    对象存在于堆内存中

Object object

    仅仅产生了一个Object引用，
    引用存在于栈内存中，
    但此时仅仅声明了一个引用，并没有指向任何Object对象    


Java的四种引用。包括：强引用，软引用，弱引用，虚引用。

# 强引用

    默认的Object object=new Object()的形式中,
    object即是对象new Object()的强引用，
    只有在object这个引用被释放后，对象才会被释放掉。
    如果一个引用是强引用，即使内存不足，GC也绝对不会回收它，而是宁可抛出OutOfMemoryError错误。
    
    
#  软引用

特点
    
    如果一个对象仅有软引用，那么当内存充足时，GC不会回收它，当内存不足时，GC会对其回收。此时，需要通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；

作用

    软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。


    通常情况下，软引用可以和一个引用队列共同使用。即当软引用的对象被GC回收后，JVM把这个软引用加入与之关联的队列中。软引用实例如下：


# 内存

 疑问五：  java对象的大小如何计算？

     基本数据类型的大小是固定的，这里就不多说了，对于非基本类型的java对象，其大小就值得商讨。

     在java中，一个空Object对象的大小是8byte，这个大小只是保存堆中一个没有任何属性的对象的大小。看看下面语句：

               Object  ob = new  Object();

     这样在程序中完成了一个java对象的声明，但是它所占的空间为：4byte+8byte。

   （4byte是上面部分所说的java栈中保存引用的所需要空间，而那8byte则是java堆中对象的信息）。

     因为所有的java非基本类型的对象都需要默认继承Object对象，因此不论什么样的java对象，其大小都必须是大于8byte。

     有了Object对象的大小，我们就可以计算其他对象的大小了。

       

       其大小为：空对象大小(8byte)+int大小(4byte)+Boolea大小(1byte)+空Object引用的大小(4byte)=17byte。

       但是因为java在对对象内存分配时都是以8的整数倍来分的，因此大于17byte的最接近8的整数倍的是24，因此此对象的大小为24byte。

       这里需要注意一下基本类型的包装类型的大小。因为这种包装类型已经成为对象了，因此需要把它们作为对象来看待。

       包装类型的大小至少是12byte(声明一个空Object至少需要的空间)，而且12byte没有包含任何有效信息，

       同时，因为java对象大小是8的整数倍，因此一个基本类型包装类的大小至少是16byte。

       这个内存占用是很恐怖的，它是使用基本类型的N倍(N>2)，这些类型的内存占用更是夸张。因此，可能的话应尽量少使用包装类。

       在JDK5.0以后，因为加入了自动类型装换，因此，java虚拟机会在存储方面进行相应的优化。    
      
# 参考

    https://www.cnblogs.com/cielosun/p/6672823.html      