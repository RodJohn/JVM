

https://blog.csdn.net/zhushuai1221/article/details/51027024

非G1回收器

# 目标

    GC的时间足够的小
    GC的次数足够的少
    发生Full GC的周期足够的长


# 

    JVM参数调优是个很头痛的问题，设置的不好，
    JVM不断执行Full GC，导致整个系统变得很慢，网站停滞时间能达10秒以上，
    这种情况如果没隔几分钟就来一次，自己都受不了。
    这种停滞在测试的时候看不出来，只有网站pv达到数十万/天的时候问题就暴露出来了。

# 考虑情况

物理机

    1核  2G
    2核  4G
    4核  8G
    8核  16G 
    
    可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制

FullGC的调节

    一些高性能、高并发的情况下，垃圾回收确成为了制约Java应用的瓶颈。目前JDK的垃圾回收算法，始终无法解决垃圾回收时的暂停问题，因为这个暂停严重影响了程序的相应时间，造成拥塞或堆积。这也是后续JDK增加G1算法

内存分配

    使用中等内存
    大内存容易造成fullgc的停顿时间过长
        12G fullgc 10多秒
        1.5G fullgc 400

运用

    中型机+docker 或者反向代理

# 设置

# 内存

## 堆



-Xmx3550m -Xms3550m 

    -Xms3550m：
        设置JVM促使内存为3550m。
        此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
        XMX和XMS设置一样大，MaxPermSize和MinPermSize设置一样大，这样可以减轻伸缩堆大小带来的压力。
        年轻代大小选择
        
    垃圾回收时promotion failed是个很头痛的问题，一般可能是两种原因产生，第一个原因是救助空间不够，救助空间里的对象还不应该被移动到年老代，但年轻代又有很多对象需要放入救助空间；第二个原因是年老代没有足够的空间接纳来自年轻代的对象；这两种情况都会转向Full GC，网站停顿时间较长。第一个原因我的最终解决办法是去掉救助空间，设置-XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0即可，第二个原因我的解决办法是设置CMSInitiatingOccupancyFraction为某个值（假设70），这样年老代空间到70%时就开始执行CMS，年老代有足够的空间接纳来自年轻代的对象。
        
        
        

-XX:NewRatio=2:

    响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。
    在此种情况下，年轻代收集发生的频率也是最小的。并发快（但是要搞掉大对象）
    同时，减少到达年老代的对象。
    
    设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。
    设置为4，则年轻代与年老代所占比值为1：4，

-XX:SurvivorRatio=4：

    设置年轻代中Eden区与Survivor区的大小比值。设置为4，
    则两个Survivor区与一个Eden区的比值为2:4，
``

-XX:MaxPermSize=16m:设置持久代大小为16m。

    可以设置的大一点
    当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载
            
-Xss128k：

    设置每个线程的堆栈大小。
    JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。
    更具应用的线程所需内存大小进行调整。
    在相同物理内存下，减小这个值能生成更多的线程。
    但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。


GC选择

    默認是吞吐量
    应该是减少垃圾收集时的停顿时间。
    
    XX:+UseConcMarkSweepGC
        
        parNew+CMS+serialOld
    
    -XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理
    
    
    年老带% 就进行回收
    
大对象的控制

    文件
    图片
    不过java
    
7：不管怎样，永久代还是会逐渐变满，所以隔三差五重起java服务器是必要的，我每天都自动重起。



# 情况

    1.系统崩溃前的一些现象：
    
    每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s
    FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC
    年老代的内存越来越大并且每次FullGC后年老代没有内存被释放
    
    