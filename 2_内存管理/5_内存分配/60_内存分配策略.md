
# 1 概述

策略

    优先分配本地线程缓冲区
    jit的栈上分配 
    大对象直接进入老年代
            避免minorGC时，数据多次复制          
            PretenureSizeThreshold
    对象优先分配在Eden区
            minorGC频繁，便于回收内存                     
    长期存活的对象进入老年代
            减少GC检测
            MaxTenuringThreshold
    动态对象年龄判定
            避免ToSurvivor爆满
    空间分配担保
 
图解

#

GC [PSYoungGen:....
    GC发生的区域
        PSYoungGen表示采用的收集器为Parallel Scavenge
        如果使用的是Serial收集器，新生代名为“Default New Generation”，显示就是“[DefNew”
        如果使用的是ParNew收集器，新生代名称为“[ParNew”，意为“Parallel New Generation”
        如果采用的是Parallel Scavenge收集器，新生代名称就是“PSYoungGen”
“Full”，说明这次GC是发生了Stop-The-World

                            

# 2 本地线程分配缓冲区

概述

    在开启了线程本地缓冲时，
    每个线程可以在堆中预先分配得到一片较小的区域，作为本地线程分配缓冲区（TLAB）。
    当该线程执行时，有对象创建的话，就在该线程的TLAB中分配内存。
    当该线程的TLAB用完了才申请堆中的空闲内存。

特点

    小区域
    
# 3 大对象直接进入老年代




概述 

    大对象是指需要大量连续内存空间的Java对象，
        最典型的大对象就是那种很长的字符串以及数组（例如上面例子的byte[]数组）。
    大对象对虚拟机内存分配来说是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。
    虚拟机提供了一个-XX:PretenureSizeThreshold参数来设置大对象的界限，大于此值则直接分配在老年代去了。
    
作用

    避免在新生代区频繁的GC时发生大量的内存赋值（Eden -- From Surviver -- ToSurviver ）  
    
VM参数

    -XX:+UseSerialGC -XX:+PrintGCDetails 
    -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
    -XX:PretenureSizeThreshold=3145728
        
代码

    @Test
    public void testAllocation1(){
        byte[] allocation1;
        
        allocation1 = new byte[4 * _1MB];
    }
  
GC日志

    Heap
     def new generation   total 9216K, used 6691K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
      eden space 8192K,  81% used [0x00000000fec00000, 0x00000000ff288f10, 0x00000000ff400000)
      from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
      to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
     tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
       the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000)
     Metaspace       used 5215K, capacity 5376K, committed 5632K, reserved 1056768K
      class space    used 609K, capacity 659K, committed 768K, reserved 1048576K


分析

    allocation1分配的是4MB，大于PretenureSizeThreshold定义的3MB阀值
    所以直接分配到老年代去了。
 
# 4 堆中优先在Eden分配

概述

    大多数情况下，对象在新生代Eden去中分配，
    Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC
    MinorGC将处理Eden和From Survivor的数据    

作用

    Eden区会频繁进行MinorGC
    便于回收大部分的对象

VM参数

    -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
    把JVM设置了不可扩展内存20MB，其中新生代10MB，老年代10MB，而新生代区域的分配比例是8:1:1，
    使用Serial/Serial Old组合收集器

代码

    private static final int _1MB = 1024*1024;
        
        public static void testAllocation(){
            byte[] allocation1,allocation2,allocation3,allocation4;
    
            allocation1 = new byte[2 * _1MB];
            allocation2 = new byte[2 * _1MB];
            allocation3 = new byte[2 * _1MB];
            allocation4 = new byte[4 * _1MB];
    }
       
GC日志    
        
     [GC (Allocation Failure) 
        [DefNew: 6709K->1023K(9216K), 0.0047844 secs] 
        6709K->1334K(19456K), 0.0055483 secs][Times: user=0.01 sys=0.00, real=0.01 secs] 
     [GC (Allocation Failure) 
        [DefNew: 7323K->0K(9216K), 0.0043779 secs] 
        7633K->7429K(19456K), 0.0044012 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
        
     Heap
      def new generation   total 9216K, used 4234K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
       eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff022ad8, 0x00000000ff400000)
       from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
       to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
      tenured generation   total 10240K, used 7429K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
        the space 10240K,  72% used [0x00000000ff600000, 0x00000000ffd414f0, 0x00000000ffd41600, 0x0000000100000000)
      Metaspace       used 5227K, capacity 5424K, committed 5632K, reserved 1056768K
       class space    used 609K, capacity 659K, committed 768K, reserved 1048576K
    
解析
    
    有“[GC……]”字眼的就是GC日志记录，
        其中GC代表MinorGC，如果是Full GC的话会直接写着Full GC
        Allocation Failure 表示内存分配失败
    Heap以下的信息是JVM关闭前的堆使用情况信息描述。    
    [DefNew: 6824K->268K(9216K), 0.0087400 secs]中
        DefNew代表使用的是代表Serial收集器，
        6824K->268K(9216K)中6284K代表新生代收集前使用内存，268K代表收集后的使用内存，而9216代表新生代的总分配内存，
        0.0087400 secs为新生代收集时间。
    外层的6824K->6412K(19456K)代表整个Java堆的收集前使用内存->收集后使用内存（总分配内存），0.0087927 secs为整个GC的收集时间
       
    allocation1、allocation2、allocation3一共需要6MB，而Eden一共有8MB，优先分配到Eden。
    但再分配allocation4的时候Eden空间不够，执行了一次Minor GC，
    由于Survivor只有1MB，不够存放allocation1、allocation2、allocation3，所以直接迁移到老年代了，
    最后Eden空闲出来了就可以放allocation4了。
    
    最后通过Heap打印信息可以看到JVM内存分配的最后状态，
    “def new generation   total 9216K, used 4446K”为allocation4最后分配新生代所占用的4MB，
    而“tenured generation   total 10240K, used 6144K”则是老年代被allocation1、allocation2、allocation3所占用的6MB了。
    
    
    
    
   
    
# 5 长期存活的对象将进入老年代
 
概述 

    对象在MinorGC后并不都会直接进入老年代，除非Survivor空间不够，
    否则此存活对象会经过多次Minor GC后还生存的话才进入老年代，
    而虚拟机默认的Minor GC次数为15次，可通过-XX:MaxTenuringThreshold进行次数设置。    
    
VM参数

    -XX:+UseSerialGC -XX:+PrintGCDetails 
    -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
    -XX:MaxTenuringThreshold=1

代码
    
    public static void testAllocation(){
        byte[] allocation1,allocation2,allocation3;
    
        allocation1 = new byte[1 * _1MB / 4];
        allocation2 = new byte[4 * _1MB];
        allocation3 = new byte[4 * _1MB];
        allocation3 = null;
        allocation3 = new byte[4 * _1MB];
    }
    
GC日志

    JDK6环境下才有这个效果
    MaxTenuringThreshold = 15
    
    [GC [DefNew: 4679K->375K(9216K), 0.0044310 secs] 4679K->4471K(19456K), 0.0044650 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
    [GC [DefNew: 4635K->375K(9216K), 0.0086340 secs] 8731K->4471K(19456K), 0.0086660 secs] [Times: user=0.00 sys=0.02, real=0.01 secs] 
    Heap
    def new generation   total 9216K, used 4635K [0xee330000, 0xeed30000, 0xeed30000)
    eden space 8192K,  52% used [0xee330000, 0xee758fe0, 0xeeb30000)
    from space 1024K,  36% used [0xeeb30000, 0xeeb8dc68, 0xeec30000)
    to   space 1024K,   0% used [0xeec30000, 0xeec30000, 0xeed30000)
    tenured generation   total 10240K, used 4096K [0xeed30000, 0xef730000, 0xef730000)
    the space 10240K,  40% used [0xeed30000, 0xef130010, 0xef130200, 0xef730000)
    compacting perm gen  total 16384K, used 1912K [0xef730000, 0xf0730000, 0xf3730000)
    the space 16384K,  11% used [0xef730000, 0xef90e3b8, 0xef90e400, 0xf0730000)
    No shared spaces configured.                           

    MaxTenuringThreshold = 1
    
    [GC [DefNew: 4679K->375K(9216K), 0.0037650 secs] 4679K->4471K(19456K), 0.0037960 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
    [GC [DefNew: 4471K->0K(9216K), 0.0010150 secs] 8567K->4471K(19456K), 0.0010580 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
    Heap
    def new generation   total 9216K, used 4423K [0xee350000, 0xeed50000, 0xeed50000)
    eden space 8192K,  54% used [0xee350000, 0xee7a1fa8, 0xeeb50000)
    from space 1024K,   0% used [0xeeb50000, 0xeeb50000, 0xeec50000)
    to   space 1024K,   0% used [0xeec50000, 0xeec50000, 0xeed50000)
    tenured generation   total 10240K, used 4471K [0xeed50000, 0xef750000, 0xef750000)
    the space 10240K,  43% used [0xeed50000, 0xef1adc50, 0xef1ade00, 0xef750000)
    compacting perm gen  total 16384K, used 1912K [0xef750000, 0xf0750000, 0xf3750000)
    the space 16384K,  11% used [0xef750000, 0xef92e3b8, 0xef92e400, 0xf0750000)
    No shared spaces configured.
    

# 6 动态对象年龄判定
   
概述
  
    为了更好地适应内存情况，
    虚拟机不是要求对象必须到达MaxTenuringThreshold才可晋升老年代的，
    而是采用动态年龄判定的方法：
    如果Servivor空间中相同年龄的对象大小大于Servivor空间的一般时，
    由于下一次的MinorGC时，这些对象如果仍然存活的话，复制到ToServivor空间时就放不下了。
    所以，在本次GC时就可以把这些对象以及年龄大于等于这些对象的直接进入老年代。

VM参数
    
    -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
    
代码

    public static void testAllocation(){
        byte[] allocation1,allocation2,allocation3,allocation4;

        allocation1 = new byte[1 * _1MB / 4];
        allocation2 = new byte[2 * _1MB / 4];//注释前后对比
        allocation3 = new byte[4 * _1MB];
        allocation4 = new byte[4 * _1MB];
        allocation3 = null;
        allocation4 = new byte[4 * _1MB];
    }        
 
GC日志

    allocation2被注释的情况下

    [GC [DefNew: 4679K->375K(9216K), 0.0033230 secs] 4679K->4471K(19456K), 0.0033590 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] 
    [GC [DefNew: 4471K->375K(9216K), 0.0145510 secs] 8567K->8567K(19456K), 0.0145810 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
    Heap
    def new generation   total 9216K, used 4798K [0xee380000, 0xeed80000, 0xeed80000)
    eden space 8192K,  54% used [0xee380000, 0xee7d1fa8, 0xeeb80000)
    from space 1024K,  36% used [0xeeb80000, 0xeebddc40, 0xeec80000)
    to   space 1024K,   0% used [0xeec80000, 0xeec80000, 0xeed80000)
    tenured generation   total 10240K, used 8192K [0xeed80000, 0xef780000, 0xef780000)
    the space 10240K,  80% used [0xeed80000, 0xef580020, 0xef580200, 0xef780000)
    compacting perm gen  total 16384K, used 1912K [0xef780000, 0xf0780000, 0xf3780000)
    the space 16384K,  11% used [0xef780000, 0xef95e3b8, 0xef95e400, 0xf0780000)
    No shared spaces configured.        
    
    
    allocation2没有注释的情况下

    [GC [DefNew: 5191K->887K(9216K), 0.0046370 secs] 5191K->4983K(19456K), 0.0048820 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
    [GC [DefNew: 4983K->0K(9216K), 0.0038680 secs] 9079K->9079K(19456K), 0.0039040 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
    Heap
    def new generation   total 9216K, used 4423K [0xee3c0000, 0xeedc0000, 0xeedc0000)
    eden space 8192K,  54% used [0xee3c0000, 0xee811fa8, 0xeebc0000)
    from space 1024K,   0% used [0xeebc0000, 0xeebc0000, 0xeecc0000)
    to   space 1024K,   0% used [0xeecc0000, 0xeecc0000, 0xeedc0000)
    tenured generation   total 10240K, used 9079K [0xeedc0000, 0xef7c0000, 0xef7c0000)
    the space 10240K,  88% used [0xeedc0000, 0xef69dc70, 0xef69de00, 0xef7c0000)
    compacting perm gen  total 16384K, used 1912K [0xef7c0000, 0xf07c0000, 0xf37c0000)
    the space 16384K,  11% used [0xef7c0000, 0xef99e3e8, 0xef99e400, 0xf07c0000)
    No shared spaces configured.
    
    
    
# 7 空间分配担保

概述   
  
    在发生Minor GC前，
    虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的空间，如果这个条件成立，那么Minor GC可以确保安全的。
    如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。
    如果允许，那么会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，
    尽管这个Minor GC是有风险的；如果小于或者HandlePromotionFailure设置不允许冒险，那么这时也要改为进行一次Full GC了。
    
作用

    为了减少Full GC执行的次数而去做的检查机制。
    
    取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。
    如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。
    虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。
    
    
注意  
  
    在JDK 6 Update 24之后，虚拟机已经不再使用HandlePromotionFailure参数了，
    规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。    
    


# 栈上分配
  
    在JVM中，堆是线程共享的，因此堆上的对象对于各个线程都是共享和可见的，只要持有对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但对于垃圾收集器来说，无论筛选可回收对象，还是回收和整理内存都需要耗费时间。
    
    如果确定一个对象的作用域不会逃逸出方法之外，那可以将这个对象分配在栈上，这样，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，无须通过垃圾收集器回收，可以减小垃圾收集器的负载。
    
    JVM允许将线程私有的对象打散分配在栈上，而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统性能。  
    栈上分配的技术基础： 
    一是逃逸分析：逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。关于逃逸分析的问题可以看我另一篇文章：
    
    二是标量替换：允许将对象打散分配在栈上，比如若一个对象拥有两个字段，会将这两个字段视作局部变量进行分配。 
    
    只能在server模式下才能启用逃逸分析，参数-XX:DoEscapeAnalysis启用逃逸分析，参数-XX:+EliminateAllocations开启标量替换（默认打开）。Java SE 6u23版本之后，HotSpot中默认就开启了逃逸分析，可以通过选项-XX:+PrintEscapeAnalysis查看逃逸分析的筛选结果。
    
    https://blog.csdn.net/yangzl2008/article/details/43202969
    
# TLAB
    
    TLAB的全称是Thread Local Allocation Buffer，即线程本地分配缓存区，这是一个线程专用的内存分配区域。  
    由于对象一般会分配在堆上，而堆是全局共享的。因此在同一时间，可能会有多个线程在堆上申请空间。因此，每次对象分配都必须要进行同步（虚拟机采用CAS配上失败重试的方式保证更新操作的原子性），而在竞争激烈的场合分配的效率又会进一步下降。JVM使用TLAB来避免多线程冲突，在给对象分配内存时，每个线程使用自己的TLAB，这样可以避免线程同步，提高了对象分配的效率。  
    TLAB本身占用eEden区空间，在开启TLAB的情况下，虚拟机会为每个Java线程分配一块TLAB空间。参数-XX:+UseTLAB开启TLAB，默认是开启的。TLAB空间的内存非常小，缺省情况下仅占有整个Eden空间的1%，当然可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。  
    由于TLAB空间一般不会很大，因此大对象无法在TLAB上进行分配，总是会直接分配在堆上。TLAB空间由于比较小，因此很容易装满。比如，一个100K的空间，已经使用了80KB，当需要再分配一个30KB的对象时，肯定就无能为力了。这时虚拟机会有两种选择，第一，废弃当前TLAB，这样就会浪费20KB空间；第二，将这30KB的对象直接分配在堆上，保留当前的TLAB，这样可以希望将来有小于20KB的对象分配请求可以直接使用这块空间。实际上虚拟机内部会维护一个叫作refill_waste的值，当请求对象大于refill_waste时，会选择在堆中分配，若小于该值，则会废弃当前TLAB，新建TLAB来分配对象。这个阈值可以使用TLABRefillWasteFraction来调整，它表示TLAB中允许产生这种浪费的比例。默认值为64，即表示使用约为1/64的TLAB空间作为refill_waste。默认情况下，TLAB和refill_waste都会在运行时不断调整的，使系统的运行状态达到最优。如果想要禁用自动调整TLAB的大小，可以使用-XX:-ResizeTLAB禁用ResizeTLAB，并使用-XX:TLABSize手工指定一个TLAB的大小。  
    -XX:+PrintTLAB可以跟踪TLAB的使用情况。一般不建议手工修改TLAB相关参数，推荐使用虚拟机默认行为。
  
  
  
  
# 回收策略




# 特别注意堆外内存的回收

    

# 参数

    https://www.cnblogs.com/znicy/p/6882424.html    