
# 1 概述

定义

    JVM Runtime Data Area（运行时数据区）
    是JVM在执行Java程序时管理的内存
    
组成

    线程私有的
        PC计数器，java栈，本地方法区
    线程共有的        
        java堆，方法区组成
    经常用到的
        直接内存

图解hotspot

[](../pic/HotspotDataArea.png)     


# 2 程序计数器

概念

    程序计数器（Program Counter Register）
    也称作为PC寄存器

作用

    标记当前线程执行的字节码位置
 
特点

    线程私有
    占用内存小
 
过程
    
    Java的多线程是对CPU进行分时复用，
    线程获取CPU时间后，为了能恢复到正确的执行位置
    每个线程都必须拥有自己的程序计数器，标记自己的执行位置                   
    
    

# 3 Java虚拟机栈

概念

    Java虚拟机栈（Java Vitual Machine Stack）
    也称作Java栈、栈

作用
    
    Java栈是线程执行Java方法的内存模型
    当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。
    当方法执行完毕之后，便会将栈帧出栈。
   
栈帧    

    在栈帧中包括
    
    局部变量表(Local Variables)、
        就是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。
        局部变量表在编译期间就确定了
    操作数栈(Operand Stack)、
        利用栈完成计算过程
    运行时常量池的引用
        因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。
    方法返回地址(Return Address)
        当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。


特点

    线程私有
    局部变量表在编译期就确定了

# 4 本地方法栈

概述

    本地方法栈（Native Method Stacks）

作用　

    本地方法栈则是为线程执行本地方法（Native Method）服务的。
    
特点
    
    线程私有
    在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。
    在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。




# 5 Java堆

概述

    Java堆（Java Heap）
    堆

作用

    用来存储对象以及数组
    但是并不是全部的实例对象都在堆中（栈上分配）
    
划分

    在采用分代收集算法的JVM中
    堆由新生代和老年代组成，
    新生代由Eden区，From Survivor区，To Survivor区组成        
 
特点

    堆是线程共享
    但是对于具体的ThreadLocal数据区是线程私有的
    
    


# 6 方法区

概述

    方法区（Method Area）
    也叫做 非堆（Non-Heap）
    
    方法区是堆的逻辑组成部分，

作用

    存储类的信息（类名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码
    在方法区中有一个非常重要的部分就是运行时常量池
    
特点

    线程共享  



## 6.2 方法区和永久代、元空间


    不同概念
    永久代：GC分代回收的概念
    方法区：java运行时数据区的概念

    在Java7之前，
        HotSpot虚拟机中将GC分代收集扩展到了方法区，
        使用永久代来实现了方法区。
        从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，
        从而不需要专门为这部分设计垃圾回收机制。
        这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。
        但是在之后的HotSpot虚拟机实现中，逐渐开始将方法区从永久代移除。
        
        -XX:PermSize 
        方法区初始大小
        -XX:MaxPermSize 
        方法区最大大小
        超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen
        
    Java7中
        已经将运行时常量池从永久代移除，
        在Java 堆（Heap）中开辟了一块区域存放运行时常量池。
    而在Java8中，
        已经彻底没有了永久代，
        用元空间实现方法区
        将方法区直接放在一个与堆不相连的元空间，
        可以使用如下参数来调节方法区的大小
        
        永久代物理是是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；
        元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。
        
        -XX:MetaspaceSize 
        元空间初始大小
        -XX:MaxMetaspaceSize  
        元空间最大大小
        超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: Metadata space
        在jdk1.7中抛出的异常是这样:java.lang.OutOfMemoryError: PermGen
        

 
       
 
 
    
 
# 7 直接内存

概念

    直接内存（Direct Memory）
    直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，
    但是会被JVM虚拟机频繁用到
 
作用
    
    在JDK1.4中新引入了NIO机制，它是一种基于通道与缓冲区的新I/O方式，
    可以直接从操作系统中分配直接内存，即在堆外分配内存，
    这样能在一些场景中提高性能，因为避免了在Java堆和Native堆中来回复制数据。
    它直接从操作系统中分配，因此不受Java堆大小的限制，
    但是会受到本机总内存的大小及处理器寻址空间的限制，
    因此它也可能导致OutOfMemoryError异常出现。
