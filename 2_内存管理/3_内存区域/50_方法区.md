

# 6 方法区

概述

    方法区（Method Area）
    也叫做 非堆（Non-Heap）
    
    方法区是堆的逻辑组成部分，

作用

    存储类的信息（类名称、方法信息、字段信息）（类加载时从类文件中提取出来的）
    静态变量、常量
    即时编译器编译后的代码等数据（比如spring使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）。
    在方法区中有一个非常重要的部分就是运行时常量池
    
特点

    线程共享  

收集

    方法区同样存在垃圾收集，因为通过用户定义的类加载器可以动态扩展java程序，一些类也会成为垃圾。jvm可以回收一个未被引用类所占的空间，以使方法区的空间最小。
    垃圾回收很少光顾这个区域，不过也是需要回收的，主要针对常量池回收，类型卸载。

# 方法区和永久代、元空间

概述

    元空间的本质和永久代类似，都是对JVM规范中方法区的实现

## 变迁

jdk1.7之前

    HotSpot虚拟机中将GC分代收集扩展到了方法区，
    使用永久代来实现了方法区。
    从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，
    从而不需要专门为这部分设计垃圾回收机制。
    这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。
    但是在之后的HotSpot虚拟机实现中，逐渐开始将方法区从永久代移除。
    
    -XX:PermSize 
    方法区初始大小
    -XX:MaxPermSize 
    方法区最大大小
    超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen
    
jdk1.7

    已经将运行时常量池从永久代移除，
    在Java 堆（Heap）中开辟了一块区域存放运行时常量池。

jdk1.8

    已经彻底没有了永久代，
    用元空间实现方法区
    将方法区直接放在一个与堆不相连的元空间，
    可以使用如下参数来调节方法区的大小
    
    永久代物理是是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；
    元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。
    
    -XX:MetaspaceSize 
    元空间初始大小
    -XX:MaxMetaspaceSize  
    元空间最大大小
    超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: Metadata space
    在jdk1.7中抛出的异常是这样:java.lang.OutOfMemoryError: PermGen

永久代

    从jdk开始，就开始了永久代的转移工作，将譬如符号引用(Symbols)转移到了native heap；
    字面量(interned strings)转移到了java heap；
    类的静态变量(class statics)转移到了java heap。
    但是永久在还存在于JDK7中，
            

# 元空间

概述
     
    JDK8，
    永久代才完全消失，使用元空间。
  
    而元空间是直接存在内存中，不在java虚拟机中的，因此元空间依赖于宿主机内存大小。
    
    为什么叫元空间，是因为这里面存储的是类的元数据信息
    
    元数据（Meta Date），关于数据的数据或者叫做用来描述数据的数据或者叫做信息的信息。
           这些定义都很是抽象，我们可以把元数据简单的理解成，最小的数据单位。元数据可以为数据说明其元素或属性（名称、大小、数据类型、等），或其结构（长度、字段、数据列），或其相关数据（位于何处、如何联系、拥有者）
    

       
     类的元数据, 字符串池, 类的静态变量将会从永久代移除, 放入Java heap或者native memory. 其中建议JVM的实现中将类的元数据放入
      native memory, 将字符串池和类的静态变量放入Java堆中. 这样可以加载多少类的元数据就不在由MaxPermSize控制,
      而由系统的实际可用空间来控制.
     
     为什么这么做呢? 减少OOM只是表因, 更深层的原因还是要合并HotSpot和JRockit的代码, JRockit从来没有一个叫永久代的东西, 但是运行良好, 也不需要开发运维人员设置这么一个永久代的大小.
     
 
## 好处

    之前不管是不是需要，JVM都会吃掉那块空间……如果设置得太小，JVM会死掉；如果设置得太大，这块内存就被JVM浪费了。理论上说，现在你完全可以不关注这个，因为JVM会在运行时自动调校为“合适的大小”；
    
    提高Full GC的性能，在Full GC期间，Metadata到Metadata pointers之间不需要扫描了，别小看这几纳秒时间；
    
    隐患就是如果程序存在内存泄露，像OOMTest那样，不停的扩展metaspace的空间，会导致机器的内存不足，所以还是要有必要的调试和监控。
    
 
 