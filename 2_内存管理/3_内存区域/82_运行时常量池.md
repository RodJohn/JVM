





# 常量池

静态常量池，
     
     即*.class文件中的常量池，
     class文件中的常量池不仅仅包含字符串(数字)字面量，
     还包含类、方法的信息，占用class文件绝大部分空间。

运行时常量池，

    则是jvm虚拟机在完成类装载操作后，
    将class文件中的常量池载入到内存中，并保存在方法区中，
    我们常说的常量池，就是指方法区中的运行时常量池。
     
         
    运行时常量池中的常量，基本来源于各个class文件中的常量池。
    
    程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。
    
           









## 6.1 运行时常量池

概念

    运行时常量池（Runtime Constant Pool）
    是方法区的一部分
    用于存放编译器生成的各种字面量和符号引用

好处

    常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
    例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。
    
    节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。
    节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。

动态性

    运行时常量是相对于常量来说的，它具备一个重要特征是：动态性。
    当然，值相同的动态常量与我们通常说的常量只是来源不同，但是都是储存在池内同一块内存区域。
    Java语言并不要求常量一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中。
    这里所说的常量包括：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）和String（也可以通过String.intern()方法可以强制将String放入常量池）



作用

    用于存放编译器生成的各种字面量和符号引用（八大基本类型的包装类型和String类型数据）
    这部分内容将在类加载后存放到运行时常量池中。
 


# 常量池位置


    jdk1,6常量池放在方法区，
    jdk1.7常量池放在堆内存，
    jdk1.8放在元空间里面，和堆相独立。



参考

    https://blog.csdn.net/ychenfeng/article/details/77413206



# 基本类型的包装类和常量池

    除了两种浮点数类型，其他基本类型的包装类都实现了常量池技术，
    这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，
    但是超出此范围仍然会去创建新的对象。

## Integer与常量池

### 示例

    @Test
    public void test1(){
        Integer i1 = 40;
        Integer i2 = 40;
        Integer i3 = 0;
        Integer i4 = new Integer(40);
        Integer i5 = new Integer(40);
        Integer i6 = new Integer(0);

        System.out.println("i1=i2   " + (i1 == i2));
        System.out.println("i1=i2+i3   " + (i1 == i2 + i3));
        System.out.println("i1=i4   " + (i1 == i4));
        System.out.println("i4=i5   " + (i4 == i5));
        System.out.println("i4=i5+i6   " + (i4 == i5 + i6));
        System.out.println("40=i5+i6   " + (40 == i5 + i6));
    }

### 解析

    Integer i1=40；Java在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。
    Integer i1 = new Integer(40);这种情况下会创建新的对象。
    语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。
    
    
    