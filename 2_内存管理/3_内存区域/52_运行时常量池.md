





# 常量池

静态常量池，
     
     即*.class文件中的常量池，
     class文件中的常量池不仅仅包含字符串(数字)字面量，
     还包含类、方法的信息，占用class文件绝大部分空间。

运行时常量池，

    则是jvm虚拟机在完成类装载操作后，
    将class文件中的常量池载入到内存中，并保存在方法区中，
    我们常说的常量池，就是指方法区中的运行时常量池。
     
         
    运行时常量池中的常量，基本来源于各个class文件中的常量池。
    
    程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。
    
           









## 6.1 运行时常量池

概念

    运行时常量池（Runtime Constant Pool）
    是方法区的一部分
    用于存放编译器生成的各种字面量和符号引用

好处

    常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
    例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。
    
    节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。
    节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。

动态性

    运行时常量是相对于常量来说的，它具备一个重要特征是：动态性。
    当然，值相同的动态常量与我们通常说的常量只是来源不同，但是都是储存在池内同一块内存区域。
    Java语言并不要求常量一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中。
    这里所说的常量包括：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）和String（也可以通过String.intern()方法可以强制将String放入常量池）



作用

    用于存放编译器生成的各种字面量和符号引用（八大基本类型的包装类型和String类型数据）
    这部分内容将在类加载后存放到运行时常量池中。
 


# 常量池位置


    jdk1,6常量池放在方法区，
    jdk1.7常量池放在堆内存，
    jdk1.8放在元空间里面，和堆相独立。



参考

    https://blog.csdn.net/ychenfeng/article/details/77413206



# 基本类型的包装类和常量池

    除了两种浮点数类型，其他基本类型的包装类都实现了常量池技术，
    这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，
    但是超出此范围仍然会去创建新的对象。

## Integer与常量池

### 示例

    @Test
    public void test1(){
        Integer i1 = 40;
        Integer i2 = 40;
        Integer i3 = 0;
        Integer i4 = new Integer(40);
        Integer i5 = new Integer(40);
        Integer i6 = new Integer(0);

        System.out.println("i1=i2   " + (i1 == i2));
        System.out.println("i1=i2+i3   " + (i1 == i2 + i3));
        System.out.println("i1=i4   " + (i1 == i4));
        System.out.println("i4=i5   " + (i4 == i5));
        System.out.println("i4=i5+i6   " + (i4 == i5 + i6));
        System.out.println("40=i5+i6   " + (40 == i5 + i6));
    }

### 解析

    Integer i1=40；Java在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。
    Integer i1 = new Integer(40);这种情况下会创建新的对象。
    语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。
    



# 字符串创建

    每当我们创建字符串常量时，JVM会首先检查字符串常量池，
    如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。
    如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。
    
    常量池，就是指方法区中的运行时常量池
    
    
# 定义

字面量定义

    String a = "chenssy";
    
    编译期间，
    在常量池中查找或者创建chenssy"对象
    将栈中的a指向常量池中的"chenssy"对象

new关键字定义

    String c = new String("chenssy");
    
    运行期间
    在常量池中查找或者创建chenssy常量
    new关键字在堆中创建一个对象chenssy
    用chenssy常量的引用构建堆chenssy对象
    堆chenssy对象赋值给栈中的c
    应用关系是：c--->chenssy--->chenssy常量。
    
图例

[](../pic/stringdefine.png)

示例

    @Test
    public void test2(){
        String str1="aaa";
        String str2="aaa";
        System.out.println(str1==str2);
        //true 
        //可以看出str1跟str2是指向同一个对象
        
        String str3=new String("aaa");
        String str4=new String("aaa");
        System.out.println(str3==str4);
        //false 
        //可以看出用new的方式是生成不同的对象 
    }
 
 
# + 运算符

常量

    常量（字面量、final）相加
    能明确值的常量
    在编译期运算结果就确定为一个字面量字符串
    

变量

    字符串变量相加，
    内部实现是先new一个StringBuilder，
    然后通过append()实现相加

示例
    
    @Test
    public void test3(){
        String str1="hello";
        String str2="world";
        String str3="helloworld";
        String str4="hello"+"world";
        String str5=str1+str2;
        String str6=new String("hello");
        String str7=new String("world");
        String str8=str6+str7;
        System.out.println(str3==str4);
        //true
        System.out.println(str3==str5);
        //false
        System.out.println(str3==str8);
        //false
        System.out.println(str3==str9);
        //false
    }

    
    String str4="hello"+"world";
    在class文件中被优化成String str4="helloworld";
    

    @Test
    public void test4() {
        String s0 = "ab";
        final String s1 = "b";
        String s2 = "b";
        String s3 = getS1();
        String s10 = "a" + s1;
        String s11 = "a" + s2;
        String s12 = "a" + s3;
        System.out.println((s0 == s10));
        //true
        System.out.println((s0 == s11));
        //false
        System.out.println((s0 == s12));
        //false
    }

    private static String getS1() {
        return "b";
    }
    
    
# intern    

作用

    调用intern()方法时，java查找常量池中是否有相同unicode的字符串常量，
    如果有，则返回其引用，
    如果没有，则在常量池中增加一个unicode等于str的字符串并返回它的引用。

    
示例

    String str1 = "abbb"; 
    String str2 = new String("abbb").intern(); 
    System.out.println(str1==str2); //true
    
         
         
         
# 参考

    https://www.cnblogs.com/xiaoxi/p/6036701.html             
    