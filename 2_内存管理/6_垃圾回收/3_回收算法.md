


# 标记清除算法

概念

    Mark-Sweep（标记-清除）

原理

    标记出所有需要被回收的对象，
    回收被标记的对象所占用的空间

图解

    
    
特点

    实现简单
    并发性能好不需要复制或者移动内存，SPW（Stop the world）
    
    容易产生内存碎片，
    碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。    
    
    
    
# 复制算法

概念
 
    Copying（复制）算法

原理

    将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。
    当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，


图解


特点

    解决内存碎片问题
    但是能够使用的内存缩减到原来的一半。
    Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。
    当大量对象存活时，需要大量的内存复制
    
# 标记整理算法

概念

    Mark-Compact（标记-整理）算法
    
原理

    完成标记之后，
    将存活对象都向一端移动，然后清理掉端边界以外的内存
    
图解



# 分代收集算法

概述

    Generational Collection（分代收集）算法
    
原理

    根据对象存活的生命周期划分为堆中的新生代、老年代和方法区的永久代
    根据不同区域不同的特点，用不同回收算法去回收垃圾。
    
    对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象
        新生代由Eden区，From Survivor区，To Survivor区组成，比例一般8:1:1  
        GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的（作为保留区域）。
        GC进行时，Eden区中所有存活的对象都会被复制到To Survivor区，
        而在From Survivor区中，
        仍存活的对象会根据它们的年龄值和总量决定去向，被移到老年代中或者To Survivor区。
        接着清空Eden区和From Survivor区，
        接着， From Survivor区和To Survivor区会交换它们的角色，
        （也就是新的To Survivor区就是上次GC清空的From Survivor）
        GC时当To Survivor区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。

    对于老年代采用是Mark-Compact算法。因为每次回收都只回收少量对象

    对永久代的回收主要回收两部分内容：废弃常量和无用的类。        

特点

    通过分代，避免提高GC效率


分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是


# GC和停顿

    安全点
    
    SPW（Stop the world）
    
    Stop The World
    
    上面说了一大堆GC的理论。但是忽略了一点：
    
    怎么确定哪些对象或内存区域是可以被回收的呢？？？
    
    在java中对于对象是否还“活着”，采用的不是像Python或者其他语言中的”引用计数”的方法。 
    java中采用的是”可达性分析”。 
    至于可达性分析的细节没必要去深究，但是由”判断对象是否还存活？”引出的另一个问题却不得不考虑，看下文。
    
    无论采用什么方法去区分哪些对象还活着，不得不做的一个让步就是：这个判定过程中必须暂时让其他所有的线程都暂时停顿，这个现象对于JVM中的各个对象来说就相当于整个世界停止了。也就是所谓的Stop The World。
    
    这个停顿当然是有必要的，比如你开始分析对象的存活状态时一个对象是无用的，当你分析完成后那个对象却让其他线程操作了变成有效对象了。
    
    所以，在整个判断过程中，要能够确保一致性。也就免不了Stop The World。
    
    当然，应用的规模越大，Stop The World带来的影响越大。 
    所以，频繁的GC GC内存过大也不见得是好事。
    

# Minor GC ，Full GC

Minor GC

     新生代GC（Minor GC）：Minor GC指发生在新生代的GC，
     因为新生代的Java对象大多都是朝生夕死，所以Minor GC非常频繁，一般回收速度也比较快。
     当Eden空间不足以为对象分配内存时，会触发Minor GC。    

Full GC 


    老年代GC（Full GC/Major GC）：
    Full GC指发生在老年代的GC，出现了Full GC一般会伴随着至少一次的Minor GC（老年代的对象大部分是Minor GC过程中从新生代进入老年代），
    比如：分配担保失败。Full GC的速度一般会比Minor GC慢10倍以上。
    Full GC触发条件：
    （1）调用System.gc时，系统建议执行Full GC，但是不必然执行
    （2）老年代空间不足
    （3）方法去空间不足
    （4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
    （5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
   

# finalize

    在对象被JVM回收之前，有一个低优先级的线程去执行。只有覆盖了finalize方法，才会执行，且只会执行一次。
    
    对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过两次标记的过程。
    第一次标记：对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。
    第二次标记：如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。
    
