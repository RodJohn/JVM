




# 垃圾收集器


    现代的商用虚拟机的都是采用分代收集的，不同的区域用不同的收集器
    
    Serial、ParNew、Parallel Scavenge用于新生代；
    CMS、Serial Old、Paralled Old用于老年代。
    并且他们相互之间以相对固定的组合使用（具体组合关系如上图）。G1是一个独立的收集器不依赖其他6种收集器。ZGC是目前JDK 11的实验收集器。


[](gccolle)
   
    垃圾收集中的并行与并发：
    
    并行（Parallel）：多条垃圾收集线程
    并发（Concurrent）：用户线程与垃圾收集线程同时执行


分代的比例



# Serial

    
特点

    新生代收集器
    使用复制算法
    使用单线程进行回收
    回收时暂停其他所有线程
    
适用情况    
    
    client模式下（内存小，回收快）
    单核CPU情况下（无需线程切换）
    
# ParNew

作用

    新生代收集器
    
特点

    Serial的多线程版本    
        使用多线程进行回收
        回收时暂停其他所有线程    
        
适用情况    
    
    多核CPU情况下
       
    ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，
    甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证能超越Serial收集器。
    当然，随着可以使用的CPU的数量增加，它对于GC时系统资源的利用还是很有好处的。
    它默认开启的收集线程数与CPU的数量相同，
    可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。
    
    除Serial外，只有它能与CMS收集器配合工作
    
# Parallel Scavenge

作用 
    
    新生代收集器
    
特点

    使用复制算法   
    使用多线程
    关注吞吐量
        （吞吐量=运行用户代码时间/CPU总时间)


参数        
    
    -XX:MaxGCPauseMillis，最大垃圾回收停顿时间。这个参数的原理是空间换时间，收集器会控制新生代的区域大小，从而尽可能保证回收少于这个最大停顿时间。简单的说就是回收的区域越小，那么耗费的时间也越小。
    所以这个参数并不是设置得越小越好。设太小的话，新生代空间会太小，从而更频繁的触发GC。
    -XX:GCTimeRatio，垃圾回收时间与总时间占比。这个是吞吐量的倒数，原理和MaxGCPauseMillis相同。
    
    因为Parallel Scavenge收集器关注的是吞吐量，所以当设置好以上参数的时候，同时不想设置各个区域大小（新生代，老年代等）。可以开启**-XX:UseAdaptiveSizePolicy**参数，让JVM监控收集的性能，动态调整这些区域大小参数。
    
        
适用情况
    
    停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能够提升用户的体验；
    而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
 
 
 # Serial Old 
 
作用
 
    老年代收集器
    
特点

    使用标记整理算法
    使用单线程 
    收集时暂停所有用户进程
    
    
适用情况

    Client模式下的虚拟机使用。
    在Server模式下，作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。
    
    
# Parallel Old

作用

    老年代收集器
    
特点

    
    采用多线程
    采用”标记－整理”算法
    关注吞吐量
    
适用情况
    
    Parallel Old收集器是Parallel Scavenge收集器的老年代版本，
    在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。   
    
    
# CMS

作用

    老年代收集器
    
特点

    使用标记清除算法
    关注最短回收停顿时间   
    由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。
    工作流程
        初始标记(initial mark)：找GC Roots
        并发标记(concurrent mark)：找引用链
        重新标记(remark)：查找变更
        并发清除(concurrent sweep)：清除
        注意初始标记和重新标记还是会stop the world，
        但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。                      

[]()         
 
缺点

    基于标记清除算法实现的，会导致有大量的空间碎片产生，
        在为大对象分配内存的时候，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前开启一次Full GC。
        为了解决这个问题，CMS收集器默认提供了一个-XX:+UseCMSCompactAtFullCollection收集开关参数（默认就是开启的)，
        用于在CMS收集器进行FullGC完开启内存碎片的合并整理过程，内存整理的过程是无法并发的，这样内存碎片问题倒是没有了，不过停顿时间不得不变长。
        虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction参数用于设置执行多少次不压缩的FULL GC后跟着来一次带压缩的
        （默认值为0，表示每次进入Full GC时都进行碎片整理）。     
        
    对cpu资源敏感
        垃圾收集线程数和每个收集线程占用cpu的时间受cpu数量影响
    
    无法处理“浮动垃圾”
        即并发清除阶段用户线程又产生的对象。
        -XX:CMSInitiatingOccupancyFranction：老年代被使用的百分比，达到时触发GC（如果等老年代占满了再GC，则GC时并发产生的对象可能就获取不到存储空间）
        CMSInitiatingOccupancyFranction过高会导致大量Concurrent Mode Failure，即老年代预留的内存无法满足程序需要。
        

    有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢？
    答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“Stop the World”这种场景下使用。
    
    
    a>.CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。
    CMS默认启动的回收线程数是：(CPU数量+3) / 4。b>.CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure“，失败后而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。
    这一部分垃圾称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分内存空间提供并发收集时的程序运作使用。
    在默认设置下，CMS收集器在老年代使用了68%的空间时就会被激活，也可以通过参数-XX:CMSInitiatingOccupancyFraction的值来提供触发百分比，以降低内存回收次数提高性能。要是CMS运行期间预留的内存无法满足程序其他线程需要，就会出现“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置的过高将会很容易导致“Concurrent Mode Failure”失败，性能反而降低。c>.最后一个缺点，CMS是基于“标记-清除”算法实现的收集器，使用“标记-清除”算法收集后，会产生大量碎片。空间碎片太多时，将会给对象分配带来很多麻烦，比如说大对象，内存空间找不到连续的空间来分配不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:UseCMSCompactAtFullCollection开关参数，用于在Full GC之后增加一个碎片整理过程，还可通过-XX:CMSFullGCBeforeCompaction参数设置执行多少次不压缩的Full GC之后，跟着来一次碎片整理过程。
    
# G1 

概念

    G1，Garbage First，
    在JDK 1.7版本正式启用，是当时最前沿的垃圾收集器。
    G1可以说是CMS的终极改进版，解决了CMS内存碎片、更多的内存空间登问题。
    虽然流程与CMS比较相似，但底层的原理已是完全不同

作用

    独自完成新生代和老年代的搜集    
    
    最前沿成果。削弱新生代与老年代概念，将整个堆划分为独立的不同Region。根据各Region的回收价值，确定优先列表。
    
    从整体来看：“标记-整理” 算法
    
    从局部（两个Region之间）来看：“复制”算法 
    
    
    堆内存结构的不同。
    
        以前的收集器分代是划分新生代、老年代、持久代等。
        G1则是把内存分为多个大小相同的区域Region，每个Region拥有各自的分代属性，但这些分代不需要连续。
        
        这样的分区可以有效避免内存碎片化问题。
        
    但是这样同样会引申一个新的问题，就是分代的内存不连续，导致在GC搜索垃圾对象的时候需要全盘扫描找出引用内存所在。
    为了解决这个问题，G1对于每个Region都维护一个Remembered Set，用于记录对象引用的情况。当GC发生的时候根据Remembered Set的引用情况去搜索。


GC模式：

    Young GC，关注于所有年轻代的Region，通过控制收集年轻代的Region个数，从而控制GC的回收时间。
    Mixed GC，关注于所有年轻代的Region，并且加上通过预测计算最大收益的若干个老年代Region。
    
        
流程

    整体的执行流程：
    
    初始标记（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。
    并发标记（concurrent marking），并发标记初始标记的对象，此时用户线程依然可以执行。
    最终标记（Remark），STW，标记再并发标记过程中产生的垃圾。
    筛选回收（Live Data Counting And Evacuation），评估标记垃圾，根据GC模式回收垃圾。STW执行。
    
    
    
参考

    http://blog.jobbole.com/109170/    
 
 
# ZGC

    在JDK 11当中，加入了实验性质的ZGC。它的回收耗时平均不到2毫秒。它是一款低停顿高并发的收集器。
    ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际是非常少的。那么其他阶段是怎么做到可以并发执行的呢？
    ZGC主要新增了两项技术，一个是着色指针Colored Pointer，另一个是读屏障Load Barrier。
    着色指针Colored Pointer
    ZGC利用指针的64位中的几位表示Finalizable、Remapped、Marked1、Marked0（ZGC仅支持64位平台），以标记该指向内存的存储状态。相当于在对象的指针上标注了对象的信息。注意，这里的指针相当于Java术语当中的引用。
    在这个被指向的内存发生变化的时候（内存在Compact被移动时），颜色就会发生变化。
    在G1的时候就说到过，Compact阶段是需要STW，否则会影响用户线程执行。那么怎么解决这个问题呢？
    读屏障Load Barrier
    由于着色指针的存在，在程序运行时访问对象的时候，可以轻易知道对象在内存的存储状态（通过指针访问对象），若请求读的内存在被着色了。那么则会触发读屏障。读屏障会更新指针再返回结果，此过程有一定的耗费，从而达到与用户线程并发的效果。
    把这两项技术联合下理解，引用R大（RednaxelaFX）的话
    
    与标记对象的传统算法相比，ZGC在指针上做标记，在访问指针时加入Load Barrier（读屏障），比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop The World。
        
# 设定垃圾收集器

默认情况
    
    jdk1.6
        
    jdk1.7/1.8
        client
            serial + serial old    
        server
            Parallel Scavenge+Parallel Old
    jdk1.9 
        G1

    查询语句
        -XX:+PrintCommandLineFlagsjvm

自定义

    设置

        

    查询
        
        jmap -heap     

JVM运行模式

    https://blog.csdn.net/Erica_1230/article/details/69934787
    
    
# 参数

    UseSerialGC : 是否使用Serial收集器 
    启用后将使用Serial + Serial Old的组合来进行垃圾回收
    这也是Client模式下的默认值
    UseParNewGC : 是否使用ParNew收集器 
    将使用ParNew + Serial Old的组合来进行垃圾回收
    UseConcMarkSweepGC 
    启用后将使用ParNew + CMS + Serial Old的组合来进行垃圾回收
    Serial Old 作为CMS的后备收集器(Concurrent Mode Failure)
    UseParallelGC 
    使用Parallel Scavenge + Serial Old的组合来进行垃圾回收
    这也是Server模式下的默认值
    UseParallelOldGC 
    使用 Parallel Scavenge + Parallel Old的组合来进行垃圾回收
    SurvivorRatio 
    新生代中Eden和Survivor的比值
    默认为8,即:Eden:Survivor=8:1
    PretenureSizeThreshold 
    这个大小值，表示对象大小大于多少之后直接分配到老年代而不进入新生代
    MaxTenuringThreshold 
    这个年龄值表示对象在经过多少次Minor GC之后就进入老年代
    每次Minor GC之后，对象的该属性值就加1
    UseAdaptiveSizePolicy 
    动态调节堆中各个区域的大小和进入老年代的年龄
    HandlePromotionFailure 
    是否允许分配担保失败
    担保失败指的是: 老年代的剩余空间大小无法容纳新生代中的Eden和Survivor的情况
    ParallelGCThreads 
    并行GC的线程数
    GCTimeRatio 
    GC时间占总时间的比例
    只有在使用Parallel Scavenge的情况下生效
    默认值：99
    MaxGCPauseMillis 
    GC的最大停顿时间
    只有在使用Parallel Scavenge的情况下生效
    CMSInitiatingOccupancyFraction 
    CMS收集器在老年代空间被占用多少后触发GC
    只对CMS收集器生效
    默认值：68%
    UseCMSCompactAtFullCollection 
    CMS收集器在完成垃圾回收后是否进行内存碎片整理
    只对CMS收集器生效
    CMSFullGCsBeforeCompaction 
    CMS经过多少次GC后再进行碎片整理
    也就是设置CMS收集器在进行N次垃圾收集后再进行一次碎片整理
    只对CMS收集器生效
