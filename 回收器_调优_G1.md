五、G1的最佳实践
1. 关键参数项


-XX:+UseG1GC，告诉JVM使用G1垃圾收集器

-XX:MaxGCPauseMillis=200，设置GC暂停时间的目标最大值，这是个柔性的目标，JVM会尽力达到这个目标

-XX:INitiatingHeapOccupancyPercent=45，如果整个堆的使用率超过这个值，G1会触发一次并发周期。记住这里针对的是整个堆空间的比例，而不是某个分代的比例。

2. 最佳实践
不要设置年轻代的大小
通过-Xmn显式设置年轻代的大小，会干扰G1收集器的默认行为：

G1不再以设定的暂停时间为目标，换句话说，如果设置了年轻代的大小，就无法实现自适应的调整来达到指定的暂停时间这个目标
G1不能按需扩大或缩小年轻代的大小

作者：javaadu
链接：https://www.jianshu.com/p/a3e6a9de7a5d
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

G1的调优
G1的调优目标主要是在避免FULL GC和疏散失败的前提下，尽量实现较短的停顿时间和较高的吞吐量。关于G1 GC的调优，需要记住以下几点：

不要自己显式设置新生代的大小（用Xmn或-XX:NewRatio参数），如果显式设置新生代的大小，会导致目标时间这个参数失效。
由于G1收集器自身已经有一套预测和调整机制了，因此我们首先的选择是相信它，即调整-XX:MaxGCPauseMillis=N参数，这也符合G1的目的——让GC调优尽量简单，这里有个取舍：如果减小这个参数的值，就意味着会调小新生代的大小，也会导致新生代GC发生得更频繁，同时，还会导致混合收集周期中回收的老年代分区减少，从而增加FULL GC的风险。这个时间设置得越短，应用的吞吐量也会受到影响。
针对混合垃圾收集的调优。如果调整这期望的最大暂停时间这个参数还是无法解决问题，即在日志中仍然可以看到FULL GC的现象，那么就需要自己手动做一些调整，可以做的调整包括：


调整G1垃圾收集的后台线程数，通过设置-XX:ConcGCThreads=n这个参数，可以增加后台标记线程的数量，帮G1赢得这场你追我赶的游戏；
调整G1垃圾收集器并发周期的频率，如果让G1更早得启动垃圾收集，也可以帮助G1赢得这场比赛，那么可以通过设置-XX:InitiatingHeapOccupancyPercent这个参数来实现这个目标，如果将这个参数调小，G1就会更早得触发并发垃圾收集周期。这个值需要谨慎设置：如果这个参数设置得太高，会导致FULL GC出现得频繁；如果这个值设置得过小，又会导致G1频繁得进行并发收集，白白浪费CPU资源。通过GC日志可以通过一个点来判断GC是否正常——在一轮并发周期结束后，需要确保堆剩下的空间小于InitiatingHeapOccupancyPercent的值。
调整G1垃圾收集器的混合收集的工作量，即在一次混合垃圾收集中尽量多处理一些分区，可以从另外一方面提高混合垃圾收集的频率。在一次混合收集中可以回收多少分区，取决于三个因素：（1）有多少个分区被认定为垃圾分区，-XX:G1MixedGCLiveThresholdPercent=n这个参数表示如果一个分区中的存活对象比例超过n，就不会被挑选为垃圾分区，因此可以通过这个参数控制每次混合收集的分区个数，这个参数的值越大，某个分区越容易被当做是垃圾分区；（2）G1在一个并发周期中，最多经历几次混合收集周期，这个可以通过-XX:G1MixedGCCountTarget=n设置，默认是8，如果减小这个值，可以增加每次混合收集收集的分区数，但是可能会导致停顿时间过长；（3）期望的GC停顿的最大值，由MaxGCPauseMillis参数确定，默认值是200ms，在混合收集周期内的停顿时间是向上规整的，如果实际运行时间比这个参数小，那么G1就能收集更多的分区。



# 并发标记周期开始后的FULL GC

G1启动了标记周期，但是在并发标记完成之前，就发生了Full GC，日志常常如下所示：

  51.408: [GC concurrent-mark-start]
  65.473: [Full GC 4095M->1395M(4096M), 6.1963770 secs]
   [Times: user=7.87 sys=0.00, real=6.20 secs]
  71.669: [GC concurrent-mark-abort]

GC concurrent-mark-start开始之后就发生了FULL GC，
这说明针对老年代分区的回收速度比较慢，
或者说对象过快得从新生代晋升到老年代，
或者说是有很多大对象直接在老年代分配。
针对上述原因，我们可能需要做的调整有：调大整个堆的大小、更快得触发并发回收周期、让更多的回收线程参与到垃圾收集的动作中。

# 混合收集模式中的FULL GC
在GC日志中观察到，在一次混合收集之后跟着一条FULL GC，
这意味着混合收集的速度太慢，在老年代释放出足够多的分区之前，应用程序就来请求比当前剩余可分配空间大的内存。
针对这种情况我们可以做的调整：增加每次混合收集收集掉的老年代分区个数；增加并发标记的线程数；提高混合收集发生的频率。

# 疏散失败（转移失败）

在新生代垃圾收集快结束时，找不到可用的分区接收存活下来的对象，常见如下的日志：
60.238: [GC pause (young) (to-space overflow), 0.41546900 secs]

这意味着整个堆的碎片化已经非常严重了，我们可以从以下几个方面调整：（1）增加整个堆的大小——通过增加-XX:G1ReservePercent选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量;（2）通过减少 -XX:InitiatingHeapOccupancyPercent提前启动标记周期；（3）
你也可以通过增加-XX:ConcGCThreads选项的值来增加并发标记线程的数目；


#巨型对象分配失败
如果在GC日志中看到莫名其妙的FULL GC日志，又对应不到上述讲过的几种情况，
那么就可以怀疑是巨型对象分配导致的，这里我们可以考虑使用jmap命令进行堆dump，
然后通过MAT对堆转储文件进行分析。关于堆转储文件的分析技巧，后续会有专门的文章介绍。

