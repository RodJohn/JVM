    


# 连接

    类的加载过程后生成了类Class对象，
    连接阶段负责将类的二进制数据合并入JRE（Java运行时环境）中。


 


## 

    通过子类引用父类的静态字段，对于父类属于“主动引用”的第一种情况，
    对于子类，没有符合“主动引用”的情况，故子类不会进行初始化

    //父类
    public class SuperClass {
        //静态变量value
        public static int value = 666;
        //静态块，父类初始化时会调用
        static{
            System.out.println("父类初始化！");
        }
    }
     
    //子类
    public class SubClass extends SuperClass{
        //静态块，子类初始化时会调用
        static{
            System.out.println("子类初始化！");
        }
    }
     
    //主类、测试类
    public class NotInit {
        public static void main(String[] args){
            System.out.println(SubClass.value);
        }
    }
    
    
    通过数组来引用类，不会触发类的初始化，因为是数组new，而类没有被new，所以没有触发任何“主动引用”条款，属于“被动引用”。
    
    
    //父类
    public class SuperClass {
    	//静态变量value
    	public static int value = 666;
    	//静态块，父类初始化时会调用
    	static{
    		System.out.println("父类初始化！");
    	}
    }
     
    //主类、测试类
    public class NotInit {
    	public static void main(String[] args){
    		SuperClass[] test = new SuperClass[10];
    	}
    }

    
    静态常量在编译阶段就会被存入调用类的常量池中，不会引用到定义常量的类，这是一个特例，需要特别记忆，不会触发类的初始化！
    
    //常量类
    public class ConstClass {
    	static{
    		System.out.println("常量类初始化！");
    	}
    	
    	public static final String HELLOWORLD = "hello world!";
    }
     
    //主类、测试类
    public class NotInit {
    	public static void main(String[] args){
    		System.out.println(ConstClass.HELLOWORLD);
    	}
    }
