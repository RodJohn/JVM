    

# 加载

## 作用

    生成类对象

## 过程

获取

    通过类的全限定名来获取类的二进制字节流
    而获取的方式，可以通过jar包、war包、网络中获取、JSP文件生成
    
转储
    
    将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    
生成对象
    
    在内存中生成代表这个类的java.lang.Class对象，
    作为方法区这个类的各种数据的访问入口。


# 连接

    类的加载过程后生成了类Class对象，
    连接阶段负责将类的二进制数据合并入JRE（Java运行时环境）中。

# 验证

## 作用

    确保被加载的类的正确性

## 理解

    一些在编译层面上可以控制的事情
    （比如超边界访问数组，跨类型进行类型对象转换存在时）
    可以通过直接修改class文件的方式进行破解，
    按照虚拟机规范，如果验证到输入的字节流不符合Class文件的存储格式，就抛出一个java.lang.VerifyError异常或其子类异常。

## 验证过程    
    
文件格式验证

    比如是否以魔数开头，主次版本号是否在虚拟机可处理范围之内，常量池是否有不支持类型等。
    经过这个阶段的验证之后，字节流才会进入内存的方法区进行存储，
    所以后面的三个验证阶段全部是基于方法区的存储结构进行的。
    
元数据验证

    对字节码描述的信息进行语义分析，以保证其描述的信息符合JAVA语言规范的要求，
    这个阶段可能包括的验证点有：
    这个类是否有父类，父类是否集成了不允许继承的类，如果不是抽象类是否实现了其父类或接口中要求实现的所有方法

字节码验证
    
    最复杂的一个解读那，主要工作是进行数据流和控制流分析。
    这阶段对类的方法体进行校验分析，保证该方法在运行时不会做出危害JVM安全的行为，
    例如：
    保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，保证跳转指令不会跳转到方法体以外的字节码指令上，保证方法体中的类型转换是有效的。。。

符号引用验证

    这个阶段发生在虚拟机将符号引用转化为直接引用的时候。
    这个转化动作将在连接的第三个阶段----解析阶段中发生。可以看作是对类自身以外的信息进行匹配性的校验。
    比如：符号引用中通过字符串描述的全限定名是否能找到对应的类，是否存在所描述的方法和字段；符号引用中的类、字段和方法的访问性是否可被当前类访问。
    它的目的是确保解析动作能正常执行。
    可以使用启动参数-Xverify:none来关闭大部分类验证措施，缩短虚拟机类加载时间。

# 准备

## 作用

    为类的静态变量分配内存，并将其初始化为默认值
    
## 过程

    在方法区中对类的静态变量进行内存分配
    
    设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等）
    
    被final修饰的变量，将在编译时生成ConstantValue属性
    同时被static和final修饰的常量，这样在准备阶段将直接设置成该初值。
  
  
# 解析

## 作用

    将常量池内的符号引用替换为直接引用。
    
## 理解    
    
    符号引用在CLASS文件中它以CONSTANT_CLASS_INFO等类型的常量出现。
    
    1.符号引用：（Symbolic References）
        符号引用以一组符号来描述所引用的目标，可以是任何形式的字面量，引用的目标并不一定已经加载到内存中，与虚拟机内存布局无关。
    2.直接引用：（Direct References）
        直接引用可以是直接指向目标的指针，相对偏移量，或是一个能间接定位到目标的句柄。与虚拟机内存布局相关。
    
    虚拟机规范并未规定解析阶段发生的具体时间，只要求了在执行anewarray,checkcast,
    getfield,getstatic,instanceof,invokeinterface,invokespecial,invokestatic,invokevirtual,
    multianewarray,new,putfield,putstatic这13个操作符号引用的字节码指令之前，先对它们使用的符号引用进行解析。
    对同一个符号引用进行多次解析请求是很常见的事情。有的实现会进行缓存。
    解析动作主要针对类/接口，字段，类方法，接口方法四类符号引用进行。分别对应于常量池的CONSTANT_CLASS_INFO,CONSTANT_FIELDREF_INFO,
    CONSTANT_METHODREF_INFO,CONSTANT_INTERFACEMETHODREF_INFO四种类型。


# 初始化

## 作用

    为类的静态变量赋予正确的初始值
    也是用户代码的体现
    
## 过程

概述    
    
    初始化阶段是执行类构造器<clinit>()方法的过程

clinit
    
    <clinit>()方法是由编译器自动收集类中的所有类变量的复制动作和静态语句块中的语句合并而成。
    编译器收集的顺序和语句在源文件中出现的顺序一致，静态语句块中只能访问到定义在它之前的变量，定义在它之后的变量，只能赋值，不能访问

    <clinit>()方法与类的构造函数<init>()不同，
    不需要显式的调用父类构造器，虚拟机会保证父类的<clinit>()在子类的之前完成。
    由于父类<clinit>()方法先执行，也就意味着父类中定义的静态语句要优先于子类的变量赋值操作。
    
    <clinit>()方法并不是必须的，如果一个类没有静态语句块也没有对变量赋值操作，就不会生成 
    接口中不能使用静态语句块，但仍有变量初始化赋值的操作，因此也会生成<clinit>()方法，但与类不同的是，接口的<clinit>()方法不需要执行父接口的<clinit>()方法。
    只有当父几口中定义的变量被使用时，父接口才初始化，另外，接口的实现类在初始化时一样不会执行接口的<clinit>()方法。
    
    虚拟机会保证一个类的<clinit>()方法在多线程环境中正确的加锁同步，
    如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都会阻塞，直到该方法执行完，
    如果在一个类的<clinit>()方法中有耗时很长的操作，可能会造成多个进程阻塞，在实际应用中，这种阻塞往往很隐蔽。


# 初始化时机

## 主动引用


    Java虚拟机规范中严格规定了有且只有五种情况必须对类进行初始化：
    
    1、使用new字节码指令创建类的实例，或者使用getstatic、putstatic读取或设置一个静态字段的值（放入常量池中的常量除外），或者调用一个静态方法的时候，对应类必须进行过初始化。
    
    2、通过java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要首先进行初始化。
    
    3、当初始化一个类的时候，如果发现其父类没有进行过初始化，则首先触发父类初始化。
    
    4、当虚拟机启动时，用户需要指定一个主类（包含main()方法的类），虚拟机会首先初始化这个类。
    
    5、使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。
    
    
    
    注意，虚拟机规范使用了“有且只有”这个词描述，这五种情况被称为“主动引用”，除了这五种情况，所有其他的类引用方式都不会触发类初始化，被称为“被动引用”。

## 

    通过子类引用父类的静态字段，对于父类属于“主动引用”的第一种情况，
    对于子类，没有符合“主动引用”的情况，故子类不会进行初始化

    //父类
    public class SuperClass {
        //静态变量value
        public static int value = 666;
        //静态块，父类初始化时会调用
        static{
            System.out.println("父类初始化！");
        }
    }
     
    //子类
    public class SubClass extends SuperClass{
        //静态块，子类初始化时会调用
        static{
            System.out.println("子类初始化！");
        }
    }
     
    //主类、测试类
    public class NotInit {
        public static void main(String[] args){
            System.out.println(SubClass.value);
        }
    }
    
    
    通过数组来引用类，不会触发类的初始化，因为是数组new，而类没有被new，所以没有触发任何“主动引用”条款，属于“被动引用”。
    
    
    //父类
    public class SuperClass {
    	//静态变量value
    	public static int value = 666;
    	//静态块，父类初始化时会调用
    	static{
    		System.out.println("父类初始化！");
    	}
    }
     
    //主类、测试类
    public class NotInit {
    	public static void main(String[] args){
    		SuperClass[] test = new SuperClass[10];
    	}
    }

    
    静态常量在编译阶段就会被存入调用类的常量池中，不会引用到定义常量的类，这是一个特例，需要特别记忆，不会触发类的初始化！
    
    //常量类
    public class ConstClass {
    	static{
    		System.out.println("常量类初始化！");
    	}
    	
    	public static final String HELLOWORLD = "hello world!";
    }
     
    //主类、测试类
    public class NotInit {
    	public static void main(String[] args){
    		System.out.println(ConstClass.HELLOWORLD);
    	}
    }
