

# 概述

    JVM把Class文件流加载到内存，
    并对数据进行校验、转换解析、初始化，
    使这些数据最终成为可以被JVM直接使用的Java类型


声明周期

    类加载的生命周期包括：加载Loading, 验证Verification, 准备Preparation, 解析Resolution, 初始化Initialization, 使用Using和卸载Unloading.
    
    
    
# 加载时机

        虚拟机规范严格规定了有且只有四种情况必须对类进行初始化（加载，验证，准备自动在之前开始）
    遇到new,getstatic,putstatic,invokestatic这4条字节码指令时，如果类没有进行初始化，则先初始化。这4个字节码常见的出现场景是：使用new关键字实例化对象的时候，读取或设置静态字段（被final修饰，已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
    反射调用时 初始化一个类时，如果其父类还未初始化，则先出发父类初始化。
    当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类这4种情况称为对类的主动引用，其他情况称为被动引用。以下是三种被动引用的情况：
    1.对于访问静态字段，只有直接定义这个字段的类才被初始化，因此通过子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。但是对于HOTSPOT,会触发子类的加载。
    2.通过数组定义引用类，不会触发此类的初始化。
    3.常量在编译阶段会存入调用类的常量池，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
    接口的加载和类加载过程稍有不同，接口不能有static代码段，但接口中还是会生成<clinit>()类构造器，用于初始化接口中所定义的成员变量。一个接口在初始化时，并不要求其父类也初始化了。
